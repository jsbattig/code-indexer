# User Story: API Client Abstraction

## 📋 **User Story**

As a **CIDX developer**, I want **clean API client abstraction layers with no raw HTTP calls in business logic**, so that **the codebase is maintainable, testable, and follows proper separation of concerns**.

## 🎯 **Business Value**

Ensures clean architecture by separating HTTP communication concerns from business logic. Creates easily testable and maintainable code with proper abstraction layers that can be mocked for unit testing and easily extended for new remote functionality.

## 📝 **Acceptance Criteria**

### Given: Clean HTTP Client Architecture
**When** I examine the codebase for remote operations  
**Then** all HTTP calls are contained within dedicated API client classes  
**And** business logic never makes raw HTTP requests directly  
**And** API clients handle authentication, retries, and error handling  
**And** clients provide clean interfaces that abstract HTTP details  

### Given: Specialized API Client Classes
**When** I review the API client implementation  
**Then** there's a base CIDXRemoteAPIClient for common HTTP functionality  
**And** specialized clients (RepositoryLinkingClient, RemoteQueryClient) for specific operations  
**And** each client has single responsibility and clear purpose  
**And** clients can be easily mocked and tested independently  

### Given: Centralized Authentication Management
**When** I examine authentication handling  
**Then** JWT token management is centralized in the base API client  
**And** automatic token refresh and re-authentication is handled transparently  
**And** credential management is abstracted from business logic  
**And** authentication failures are handled consistently across all clients  

### Given: Comprehensive Error Handling
**When** I test API client error scenarios  
**Then** network errors are handled gracefully with appropriate retries  
**And** HTTP status codes are translated to meaningful exceptions  
**And** error messages provide actionable guidance for users  
**And** clients don't leak HTTP implementation details in exceptions  

## 🏗️ **Technical Implementation**

### Base API Client Architecture
```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, Optional\nimport httpx\nfrom urllib.parse import urljoin\n\nclass CIDXRemoteAPIClient:\n    \"\"\"Base API client with authentication and common HTTP functionality.\"\"\"\n    \n    def __init__(self, server_url: str, credentials: EncryptedCredentials):\n        self.server_url = server_url.rstrip('/')\n        self.credentials = credentials\n        self.jwt_manager = JWTTokenManager()\n        self.session = httpx.AsyncClient(timeout=30.0)\n        self._current_token: Optional[str] = None\n    \n    async def _get_valid_token(self) -> str:\n        \"\"\"Get valid JWT token, refreshing if necessary.\"\"\"\n        if self._current_token:\n            try:\n                # Check if current token is still valid\n                self.jwt_manager.validate_token(self._current_token)\n                return self._current_token\n            except TokenExpiredError:\n                # Token expired, need to refresh or re-authenticate\n                pass\n        \n        # Authenticate and get new token\n        return await self._authenticate()\n    \n    async def _authenticate(self) -> str:\n        \"\"\"Authenticate with server and get JWT token.\"\"\"\n        decrypted_creds = self.credentials.decrypt()\n        \n        auth_response = await self.session.post(\n            urljoin(self.server_url, '/api/auth/login'),\n            json={\n                'username': decrypted_creds.username,\n                'password': decrypted_creds.password\n            }\n        )\n        \n        if auth_response.status_code != 200:\n            raise AuthenticationError(\"Failed to authenticate with server\")\n        \n        token_data = auth_response.json()\n        self._current_token = token_data['access_token']\n        return self._current_token\n    \n    async def _authenticated_request(\n        self, \n        method: str, \n        endpoint: str, \n        **kwargs\n    ) -> httpx.Response:\n        \"\"\"Make authenticated HTTP request with automatic token management.\"\"\"\n        token = await self._get_valid_token()\n        \n        headers = kwargs.get('headers', {})\n        headers['Authorization'] = f'Bearer {token}'\n        kwargs['headers'] = headers\n        \n        url = urljoin(self.server_url, endpoint)\n        \n        try:\n            response = await self.session.request(method, url, **kwargs)\n            \n            # Handle token expiration during request\n            if response.status_code == 401:\n                # Token may have expired between validation and request\n                self._current_token = None\n                token = await self._get_valid_token()\n                headers['Authorization'] = f'Bearer {token}'\n                response = await self.session.request(method, url, **kwargs)\n            \n            return response\n            \n        except httpx.RequestError as e:\n            raise NetworkError(f\"Network request failed: {str(e)}\")\n    \n    async def close(self):\n        \"\"\"Clean up HTTP session.\"\"\"\n        await self.session.aclose()\n```\n\n### Specialized Repository Linking Client\n```python\nclass RepositoryLinkingClient(CIDXRemoteAPIClient):\n    \"\"\"Client for repository discovery and linking operations.\"\"\"\n    \n    async def discover_repositories(self, repo_url: str) -> RepositoryDiscoveryResponse:\n        \"\"\"Find matching repositories by git origin URL.\"\"\"\n        response = await self._authenticated_request(\n            'GET', \n            '/api/repos/discover',\n            params={'repo_url': repo_url}\n        )\n        \n        if response.status_code != 200:\n            raise RepositoryDiscoveryError(\n                f\"Failed to discover repositories: {response.status_code}\"\n            )\n        \n        data = response.json()\n        return RepositoryDiscoveryResponse.parse_obj(data)\n    \n    async def get_golden_repository_branches(self, alias: str) -> List[BranchInfo]:\n        \"\"\"Get available branches for golden repository.\"\"\"\n        response = await self._authenticated_request(\n            'GET', \n            f'/api/repos/golden/{alias}/branches'\n        )\n        \n        if response.status_code == 404:\n            raise RepositoryNotFoundError(f\"Golden repository '{alias}' not found\")\n        elif response.status_code != 200:\n            raise RepositoryAccessError(\n                f\"Failed to access repository branches: {response.status_code}\"\n            )\n        \n        data = response.json()\n        return [BranchInfo.parse_obj(branch) for branch in data['branches']]\n    \n    async def activate_repository(\n        self, \n        golden_alias: str, \n        branch: str, \n        user_alias: str\n    ) -> ActivatedRepository:\n        \"\"\"Activate a golden repository for user access.\"\"\"\n        response = await self._authenticated_request(\n            'POST',\n            '/api/repos/activate',\n            json={\n                'golden_alias': golden_alias,\n                'branch': branch,\n                'user_alias': user_alias\n            }\n        )\n        \n        if response.status_code != 201:\n            raise RepositoryActivationError(\n                f\"Failed to activate repository: {response.status_code}\"\n            )\n        \n        data = response.json()\n        return ActivatedRepository.parse_obj(data)\n```\n\n### Specialized Remote Query Client\n```python\nclass RemoteQueryClient(CIDXRemoteAPIClient):\n    \"\"\"Client for remote semantic search operations.\"\"\"\n    \n    async def execute_query(\n        self, \n        repository_alias: str,\n        query: str, \n        limit: int = 10,\n        **options\n    ) -> List[QueryResultItem]:\n        \"\"\"Execute semantic search query on remote repository.\"\"\"\n        response = await self._authenticated_request(\n            'POST',\n            f'/api/repos/{repository_alias}/query',\n            json={\n                'query': query,\n                'limit': limit,\n                **options\n            }\n        )\n        \n        if response.status_code == 404:\n            raise RepositoryNotFoundError(\n                f\"Repository '{repository_alias}' not found or not accessible\"\n            )\n        elif response.status_code != 200:\n            raise QueryExecutionError(\n                f\"Query execution failed: {response.status_code}\"\n            )\n        \n        data = response.json()\n        return [QueryResultItem.parse_obj(item) for item in data['results']]\n    \n    async def get_repository_info(self, repository_alias: str) -> RepositoryInfo:\n        \"\"\"Get information about remote repository.\"\"\"\n        response = await self._authenticated_request(\n            'GET',\n            f'/api/repos/{repository_alias}'\n        )\n        \n        if response.status_code == 404:\n            raise RepositoryNotFoundError(\n                f\"Repository '{repository_alias}' not found\"\n            )\n        elif response.status_code != 200:\n            raise RepositoryAccessError(\n                f\"Failed to get repository info: {response.status_code}\"\n            )\n        \n        data = response.json()\n        return RepositoryInfo.parse_obj(data)\n```\n\n### Business Logic Integration Example\n```python\n# Clean business logic that uses API client abstraction\nasync def execute_remote_query(query: str, limit: int, project_root: Path) -> List[QueryResultItem]:\n    \"\"\"Execute query in remote mode - no HTTP code here.\"\"\"\n    # Load configuration (no HTTP)\n    remote_config = load_remote_config(project_root)\n    \n    # Create specialized client (abstracts HTTP)\n    query_client = RemoteQueryClient(\n        remote_config.server_url,\n        remote_config.credentials\n    )\n    \n    try:\n        # Execute query through clean interface (HTTP abstracted)\n        results = await query_client.execute_query(\n            remote_config.repository_link.alias,\n            query,\n            limit\n        )\n        \n        # Apply staleness detection (business logic)\n        enhanced_results = apply_staleness_detection(results, project_root)\n        \n        return enhanced_results\n        \n    finally:\n        await query_client.close()\n```\n\n## 🧪 **Testing Requirements**\n\n### Unit Tests\n- ✅ Base API client authentication and token management\n- ✅ Specialized client functionality with mocked HTTP responses\n- ✅ Error handling and exception translation\n- ✅ Business logic integration without actual HTTP calls\n\n### Integration Tests\n- ✅ End-to-end API client functionality with real server\n- ✅ Authentication flows including token refresh scenarios\n- ✅ Network error handling and retry logic\n- ✅ Client cleanup and resource management\n\n### Mock Testing Strategy\n- ✅ Easy mocking of API clients for business logic testing\n- ✅ Consistent mock interfaces across different client types\n- ✅ Error scenario mocking for comprehensive test coverage\n- ✅ Performance testing without network dependencies\n\n## ⚙️ **Implementation Pseudocode**\n\n### API Client Architecture Pattern\n```\nCLASS CIDXRemoteAPIClient:\n    FUNCTION __init__(server_url, credentials):\n        self.server_url = normalize_url(server_url)\n        self.credentials = credentials\n        self.session = create_http_session()\n        self.jwt_manager = JWTTokenManager()\n    \n    ASYNC FUNCTION _authenticated_request(method, endpoint, **kwargs):\n        token = AWAIT get_valid_token()\n        headers = add_auth_header(kwargs.get('headers'), token)\n        \n        TRY:\n            response = AWAIT self.session.request(method, endpoint, headers=headers)\n            IF response.status == 401:  # Token expired during request\n                token = AWAIT refresh_token()\n                response = AWAIT retry_request_with_new_token()\n            RETURN response\n        CATCH NetworkError:\n            RAISE NetworkError with user-friendly message\n```\n\n### Specialized Client Pattern\n```\nCLASS RepositoryLinkingClient(CIDXRemoteAPIClient):\n    ASYNC FUNCTION discover_repositories(repo_url):\n        response = AWAIT _authenticated_request('GET', '/api/repos/discover', params={'repo_url': repo_url})\n        \n        VALIDATE response.status_code\n        data = parse_json_response(response)\n        RETURN RepositoryDiscoveryResponse(data)\n```\n\n## ⚠️ **Edge Cases and Error Handling**\n\n### Authentication Edge Cases\n- Server authentication endpoint changes -> graceful failure with guidance\n- Credentials corrupted during runtime -> attempt re-authentication\n- Multiple concurrent requests during token refresh -> synchronize token updates\n- Server rejects valid credentials -> clear error message with troubleshooting steps\n\n### Network and Connection Issues\n- Intermittent connectivity -> exponential backoff retry strategy\n- Server maintenance mode -> detect and provide maintenance guidance\n- Timeout during large responses -> configurable timeout with progress indication\n- SSL/TLS certificate issues -> clear security-related error messages\n\n### HTTP Error Handling\n- 4xx client errors -> translate to user-friendly exceptions with guidance\n- 5xx server errors -> suggest retry with exponential backoff\n- Unexpected response formats -> graceful parsing failure with logging\n- Rate limiting responses -> respect rate limits and retry appropriately\n\n### Resource Management\n- Proper HTTP session cleanup -> implement context managers\n- Memory leaks from unclosed connections -> automatic cleanup on errors\n- Connection pooling optimization -> configure appropriate pool sizes\n- Concurrent request limits -> implement request queuing if necessary\n\n## 📊 **Definition of Done**\n\n- ✅ Base CIDXRemoteAPIClient implemented with authentication and common HTTP functionality\n- ✅ Specialized clients (RepositoryLinkingClient, RemoteQueryClient) created with single responsibilities\n- ✅ No raw HTTP calls exist in business logic - all abstracted through clients\n- ✅ Comprehensive error handling translates HTTP errors to meaningful exceptions\n- ✅ JWT token management with automatic refresh and re-authentication\n- ✅ Easy mocking interface for unit testing business logic\n- ✅ Proper resource management with connection cleanup\n- ✅ Integration tests validate end-to-end client functionality\n- ✅ Unit tests achieve >95% coverage with mocked dependencies\n- ✅ Code review confirms clean architecture and separation of concerns\n- ✅ Documentation explains client architecture and usage patterns