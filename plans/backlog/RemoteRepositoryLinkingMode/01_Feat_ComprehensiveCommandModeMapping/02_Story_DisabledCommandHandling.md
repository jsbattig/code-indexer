# User Story: Disabled Command Handling

## 📋 **User Story**

As a **CIDX user in remote mode**, I want **clear error messages when I try to use commands that aren't compatible with remote mode**, so that **I understand why the command isn't available and what alternatives exist**.

## 🎯 **Business Value**

Prevents user confusion and frustration by providing clear guidance when attempting to use local-only commands in remote mode. Users understand the architectural reasons for command limitations and receive actionable alternatives.

## 📝 **Acceptance Criteria**

### Given: Local-Only Command Identification
**When** I attempt to use local-only commands in remote mode  
**Then** the system identifies incompatible commands (start, stop, index, watch)  
**And** provides immediate clear error messages  
**And** explains why the command is disabled in remote mode  
**And** suggests appropriate alternatives when available  

### Given: Clear Error Messaging
**When** I receive disabled command error messages  
**Then** the message explains the architectural reason (no local containers in remote mode)  
**And** provides context about what remote mode offers instead  
**And** suggests equivalent functionality when possible  
**And** maintains consistent error message format across commands  

### Given: Command Discovery Prevention
**When** I use help or command completion in remote mode  
**Then** disabled commands are clearly marked as unavailable  
**And** help text explains command availability by mode  
**And** command completion doesn't suggest disabled commands  
**And** users can discover what commands are available  

### Given: Educational Error Responses
**When** I encounter disabled command errors  
**Then** the system explains the conceptual difference between modes  
**And** clarifies that remote mode uses server-side indexing  
**And** provides guidance on mode-specific workflows  
**And** suggests documentation for learning more  

## 🏗️ **Technical Implementation**

### Command Compatibility Matrix
```python
COMMAND_COMPATIBILITY = {
    # Always available commands
    \"help\": {\"local\": True, \"remote\": True, \"uninitialized\": True},\n    \"version\": {\"local\": True, \"remote\": True, \"uninitialized\": True},\n    \n    # Core functionality commands\n    \"query\": {\"local\": True, \"remote\": True, \"uninitialized\": False},\n    \n    # Initialization commands\n    \"init\": {\"local\": True, \"remote\": True, \"uninitialized\": True},\n    \n    # Local-only infrastructure commands\n    \"start\": {\"local\": True, \"remote\": False, \"uninitialized\": False},\n    \"stop\": {\"local\": True, \"remote\": False, \"uninitialized\": False},\n    \"index\": {\"local\": True, \"remote\": False, \"uninitialized\": False},\n    \"watch\": {\"local\": True, \"remote\": False, \"uninitialized\": False},\n    \n    # Mode-adapted commands (different behavior per mode)\n    \"status\": {\"local\": True, \"remote\": True, \"uninitialized\": False},\n    \"uninstall\": {\"local\": True, \"remote\": True, \"uninitialized\": False},\n}\n\nCOMMAND_ALTERNATIVES = {\n    \"start\": \"Remote mode uses server-side containers. Use 'cidx query' directly.\",\n    \"stop\": \"Remote mode doesn't manage local containers. Server containers are always available.\",\n    \"index\": \"Remote mode uses server-side indexing. Repository linking provides access to indexed content.\",\n    \"watch\": \"Remote mode doesn't support file watching. Query server indexes directly for latest content.\",\n}\n```\n\n### Command Compatibility Decorator\n```python\ndef require_mode(*allowed_modes):\n    \"\"\"Decorator to enforce command mode compatibility.\"\"\"\n    def decorator(command_func):\n        @functools.wraps(command_func)\n        def wrapper(*args, **kwargs):\n            ctx = click.get_current_context()\n            current_mode = ctx.obj.get('mode')\n            \n            if current_mode not in allowed_modes:\n                command_name = ctx.info_name\n                raise DisabledCommandError(command_name, current_mode, allowed_modes)\n            \n            return command_func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n# Usage examples\n@cli.command(\"start\")\n@require_mode(\"local\")\ndef start_command():\n    \"\"\"Start local CIDX services (local mode only).\"\"\"\n    # Implementation...\n\n@cli.command(\"query\")\n@require_mode(\"local\", \"remote\")\ndef query_command():\n    \"\"\"Execute semantic search (available in both modes).\"\"\"\n    # Implementation...\n```\n\n### Custom Exception Classes\n```python\nclass DisabledCommandError(ClickException):\n    \"\"\"Exception for commands disabled in current mode.\"\"\"\n    \n    def __init__(self, command_name: str, current_mode: str, allowed_modes: List[str]):\n        self.command_name = command_name\n        self.current_mode = current_mode\n        self.allowed_modes = allowed_modes\n        \n        # Generate helpful error message\n        message = self._generate_error_message()\n        super().__init__(message)\n    \n    def _generate_error_message(self) -> str:\n        \"\"\"Generate contextual error message with alternatives.\"\"\"\n        mode_description = {\n            \"local\": \"local mode (using containers and local indexing)\",\n            \"remote\": \"remote mode (using server-side repositories)\",\n            \"uninitialized\": \"uninitialized repository\"\n        }\n        \n        base_message = (\n            f\"Command '{self.command_name}' is not available in {mode_description[self.current_mode]}. \"\n            f\"This command requires: {', '.join(self.allowed_modes)}.\"\n        )\n        \n        # Add specific guidance for common commands\n        alternative = COMMAND_ALTERNATIVES.get(self.command_name)\n        if alternative:\n            base_message += f\"\\n\\n💡 {alternative}\"\n        \n        # Add mode-specific guidance\n        if self.current_mode == \"remote\":\n            base_message += (\n                \"\\n\\nℹ️ Remote mode connects to server-side repositories and doesn't manage local containers. \"\n                \"Use 'cidx query' to search remote indexes or 'cidx status' to see remote repository information.\"\n            )\n        \n        return base_message\n```\n\n### Help System Integration\n```python\nclass ModeAwareHelpFormatter(click.HelpFormatter):\n    \"\"\"Help formatter that shows command availability by mode.\"\"\"\n    \n    def write_usage(self, prog, args='', prefix='Usage: '):\n        ctx = click.get_current_context()\n        current_mode = ctx.obj.get('mode', 'unknown')\n        \n        # Add mode indicator to usage line\n        mode_indicator = f\" [Current mode: {current_mode}]\"\n        super().write_usage(prog, args, prefix + mode_indicator)\n    \n    def write_heading(self, heading):\n        if heading == \"Commands\":\n            ctx = click.get_current_context()\n            current_mode = ctx.obj.get('mode')\n            \n            super().write_heading(\"Available Commands\")\n            if current_mode:\n                self.write(f\"\\n  Commands available in {current_mode} mode:\\n\")\n        else:\n            super().write_heading(heading)\n```\n\n## 🧪 **Testing Requirements**\n\n### Unit Tests\n- ✅ Command compatibility matrix validation for all modes\n- ✅ DisabledCommandError exception generation with appropriate messages\n- ✅ Mode requirement decorator functionality\n- ✅ Help system integration with mode awareness\n\n### Integration Tests\n- ✅ End-to-end disabled command scenarios in remote mode\n- ✅ Error message clarity and actionability\n- ✅ Help command output in different modes\n- ✅ Command completion behavior (if implemented)\n\n### User Experience Tests\n- ✅ Error message comprehensibility for non-technical users\n- ✅ Alternative suggestion accuracy and usefulness\n- ✅ Consistency of error format across different disabled commands\n- ✅ Help system utility for discovering available commands\n\n## ⚙️ **Implementation Pseudocode**\n\n### Command Execution Validation\n```\nFUNCTION validate_command_compatibility(command_name, current_mode):\n    compatibility = COMMAND_COMPATIBILITY.get(command_name)\n    \n    IF NOT compatibility:\n        RAISE UnknownCommandError(command_name)\n    \n    IF NOT compatibility.get(current_mode, False):\n        allowed_modes = [mode for mode, allowed in compatibility.items() if allowed]\n        RAISE DisabledCommandError(command_name, current_mode, allowed_modes)\n    \n    RETURN True  # Command is compatible\n```\n\n### Error Message Generation\n```\nFUNCTION generate_disabled_command_message(command_name, current_mode):\n    base_message = f\"Command '{command_name}' not available in {current_mode} mode.\"\n    \n    # Add specific alternative if available\n    IF command_name IN COMMAND_ALTERNATIVES:\n        alternative = COMMAND_ALTERNATIVES[command_name]\n        base_message += f\"\\n\\n💡 {alternative}\"\n    \n    # Add mode-specific context\n    IF current_mode == \"remote\":\n        base_message += \"\\n\\nℹ️ Remote mode uses server-side indexing...\"\n    \n    RETURN base_message\n```\n\n## ⚠️ **Edge Cases and Error Handling**\n\n### Unknown Commands\n- Commands not in compatibility matrix -> standard Click \"No such command\" error\n- Typos in command names -> suggest closest valid command name\n- Custom commands or plugins -> handle gracefully with mode checking\n\n### Mode Transition Scenarios\n- User switches from local to remote -> commands that worked before now disabled\n- Provide migration guidance for common workflow patterns\n- Clear explanation of architectural differences between modes\n\n### Help System Edge Cases\n- Mode detection failures -> show all commands with mode requirements\n- Uninitialized repositories -> show initialization options prominently\n- Multiple configuration types -> clear precedence explanation\n\n### Error Message Localization\n- Consistent terminology across all error messages\n- Technical accuracy without overwhelming users\n- Actionable suggestions that actually work\n- Links to documentation when appropriate\n\n## 📊 **Definition of Done**\n\n- ✅ Command compatibility matrix defined for all CIDX commands\n- ✅ DisabledCommandError exception class with contextual messages\n- ✅ Mode requirement decorator implemented and applied to relevant commands\n- ✅ Help system enhanced with mode awareness\n- ✅ Error messages provide clear alternatives and explanations\n- ✅ Comprehensive testing of disabled command scenarios\n- ✅ User experience validation of error message clarity\n- ✅ Integration with existing Click CLI framework\n- ✅ Documentation updated with command availability by mode\n- ✅ Code review confirms user experience and error handling quality