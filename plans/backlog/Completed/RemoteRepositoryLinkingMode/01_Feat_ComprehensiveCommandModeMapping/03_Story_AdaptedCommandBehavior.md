# User Story: Adapted Command Behavior

## üìã **User Story**

As a **CIDX user in remote mode**, I want **status and uninstall commands to show remote-specific information and behavior**, so that **I can manage my remote repository configuration and understand the current state of my remote connection**.

## üéØ **Business Value**

Provides essential management and monitoring capabilities for remote mode by adapting existing commands to remote context. Users can understand their remote repository state, connection status, and perform cleanup operations appropriate for remote mode.

## üìù **Acceptance Criteria**

### Given: Remote-Aware Status Command
**When** I run `cidx status` in remote mode  
**Then** the command shows remote repository connection information  
**And** displays current remote repository alias and server details  
**And** indicates repository linking status and branch information  
**And** shows last successful query timestamp and connection health  

### Given: Remote Connection Health Monitoring
**When** I check status in remote mode  
**Then** the system tests connectivity to remote server  
**And** validates JWT token status and expiration  
**And** shows repository accessibility and permissions  
**And** provides guidance for connection issues  

### Given: Remote-Aware Uninstall Command
**When** I run `cidx uninstall` in remote mode  
**Then** the command removes remote configuration safely  
**And** clears encrypted credential storage  
**And** preserves local files and project structure  
**And** provides confirmation of successful remote disconnection  

### Given: Status Information Completeness
**When** I examine remote status output  
**Then** the information helps troubleshoot remote connection issues  
**And** shows enough detail for repository management decisions  
**And** indicates staleness of remote repository data  
**And** provides actionable next steps when issues exist  

## üèóÔ∏è **Technical Implementation**

### Remote Status Command Implementation
```python
@cli.command(\"status\")\n@click.pass_context\ndef status_command(ctx):\n    \"\"\"Show repository status (adapted for current mode).\"\"\"\n    mode = ctx.obj['mode']\n    project_root = ctx.obj['project_root']\n    \n    if mode == \"local\":\n        return display_local_status(project_root)\n    elif mode == \"remote\":\n        return display_remote_status(project_root)\n    else:\n        return display_uninitialized_status(project_root)\n\nasync def display_remote_status(project_root: Path):\n    \"\"\"Display comprehensive remote mode status information.\"\"\"\n    try:\n        # Load remote configuration\n        remote_config = load_remote_config(project_root)\n        \n        click.echo(\"üåê CIDX Remote Mode Status\")\n        click.echo(\"=\" * 40)\n        \n        # Server connection information\n        click.echo(f\"üì° Server: {remote_config.server_url}\")\n        click.echo(f\"üë§ Username: {remote_config.username}\")\n        \n        # Repository linking information\n        if remote_config.repository_link:\n            repo_link = remote_config.repository_link\n            click.echo(f\"üìÅ Linked Repository: {repo_link.alias} ({repo_link.type})\")\n            click.echo(f\"üåø Branch: {repo_link.branch}\")\n            click.echo(f\"üîó Git URL: {repo_link.git_url}\")\n        \n        # Test connection health\n        click.echo(\"\\n‚ö° Connection Health:\")\n        await test_remote_connection_health(remote_config)\n        \n        # Repository staleness information\n        await display_repository_staleness_info(remote_config)\n        \n    except Exception as e:\n        click.echo(f\"‚ùå Error retrieving remote status: {str(e)}\")\n        click.echo(\"üí° Try 'cidx init --remote' to reconfigure remote connection\")\n```\n\n### Connection Health Testing\n```python\nasync def test_remote_connection_health(remote_config: RemoteConfig):\n    \"\"\"Test various aspects of remote connection health.\"\"\"\n    api_client = CIDXRemoteAPIClient(remote_config.server_url, remote_config.credentials)\n    \n    try:\n        # Test basic connectivity\n        click.echo(\"  üîå Server connectivity: \", nl=False)\n        await api_client.ping()\n        click.echo(\"‚úÖ Connected\")\n        \n        # Test authentication\n        click.echo(\"  üîê Authentication: \", nl=False)\n        user_info = await api_client.get_user_info()\n        click.echo(f\"‚úÖ Authenticated as {user_info.username}\")\n        \n        # Test repository access\n        if remote_config.repository_link:\n            click.echo(\"  üìÅ Repository access: \", nl=False)\n            repo_info = await api_client.get_repository_info(remote_config.repository_link.alias)\n            click.echo(f\"‚úÖ {repo_info.type} repository accessible\")\n        \n    except ConnectionError:\n        click.echo(\"‚ùå Cannot connect to server\")\n        click.echo(\"üí° Check network connectivity and server URL\")\n    except AuthenticationError:\n        click.echo(\"‚ùå Authentication failed\")\n        click.echo(\"üí° Use 'cidx auth update' to refresh credentials\")\n    except RepositoryAccessError:\n        click.echo(\"‚ùå Repository not accessible\")\n        click.echo(\"üí° Repository may have been moved or permissions changed\")\n```\n\n### Repository Staleness Information\n```python\nasync def display_repository_staleness_info(remote_config: RemoteConfig):\n    \"\"\"Show information about local vs remote file states.\"\"\"\n    if not remote_config.repository_link:\n        return\n    \n    click.echo(\"\\nüìä Repository Staleness:\")\n    \n    try:\n        # Get local git state\n        git_service = GitTopologyService(Path.cwd())\n        local_branch = git_service.get_current_branch()\n        \n        # Compare with remote repository\n        if local_branch == remote_config.repository_link.branch:\n            click.echo(f\"  üåø Branch match: {local_branch} (optimal)\")\n        else:\n            click.echo(f\"  ‚ö†Ô∏è Branch mismatch: local={local_branch}, remote={remote_config.repository_link.branch}\")\n            click.echo(\"     üí° Consider switching branches or relinking to appropriate remote branch\")\n        \n        # Check for local uncommitted changes\n        staged_files = git_service._get_staged_files()\n        unstaged_files = git_service._get_unstaged_files()\n        \n        if staged_files or unstaged_files:\n            total_changes = len(staged_files) + len(unstaged_files)\n            click.echo(f\"  üìù Local changes: {total_changes} files modified\")\n            click.echo(\"     üí° Query results may not reflect your latest changes\")\n        else:\n            click.echo(\"  ‚úÖ No local changes - results should be current\")\n            \n    except Exception as e:\n        click.echo(f\"  ‚ùå Could not analyze repository staleness: {str(e)}\")\n```\n\n### Remote Uninstall Command Implementation\n```python\n@cli.command(\"uninstall\")\n@click.option('--confirm', is_flag=True, help='Skip confirmation prompt')\n@click.pass_context\ndef uninstall_command(ctx, confirm: bool):\n    \"\"\"Uninstall CIDX configuration (mode-specific behavior).\"\"\"\n    mode = ctx.obj['mode']\n    project_root = ctx.obj['project_root']\n    \n    if mode == \"local\":\n        return uninstall_local_mode(project_root, confirm)\n    elif mode == \"remote\":\n        return uninstall_remote_mode(project_root, confirm)\n    else:\n        click.echo(\"No CIDX configuration found to uninstall.\")\n\ndef uninstall_remote_mode(project_root: Path, confirm: bool):\n    \"\"\"Safely remove remote mode configuration and credentials.\"\"\"\n    config_dir = project_root / \".code-indexer\"\n    \n    if not confirm:\n        click.echo(\"üåê Uninstalling CIDX Remote Mode Configuration\")\n        click.echo(\"=\"* 45)\n        \n        # Show what will be removed\n        remote_config_path = config_dir / \".remote-config\"\n        credentials_path = config_dir / \".creds\"\n        \n        click.echo(\"\\nüìÅ Files to be removed:\")\n        if remote_config_path.exists():\n            click.echo(f\"  ‚Ä¢ {remote_config_path}\")\n        if credentials_path.exists():\n            click.echo(f\"  ‚Ä¢ {credentials_path}\")\n        \n        click.echo(\"\\n‚úÖ Preserved (not removed):\")\n        click.echo(\"  ‚Ä¢ Local files and project structure\")\n        click.echo(\"  ‚Ä¢ Git repository and history\")\n        click.echo(\"  ‚Ä¢ Other project configurations\")\n        \n        if not click.confirm(\"\\n‚ùì Proceed with remote configuration removal?\"):\n            click.echo(\"‚ùå Uninstall cancelled\")\n            return\n    \n    try:\n        # Remove remote configuration files\n        removed_files = []\n        \n        remote_config_path = config_dir / \".remote-config\"\n        if remote_config_path.exists():\n            remote_config_path.unlink()\n            removed_files.append(\".remote-config\")\n        \n        credentials_path = config_dir / \".creds\"\n        if credentials_path.exists():\n            credentials_path.unlink()\n            removed_files.append(\".creds\")\n        \n        # Remove config directory if empty\n        if config_dir.exists() and not any(config_dir.iterdir()):\n            config_dir.rmdir()\n            removed_files.append(\".code-indexer/ (empty directory)\")\n        \n        click.echo(\"‚úÖ Remote configuration successfully removed\")\n        if removed_files:\n            click.echo(f\"üìÅ Removed: {', '.join(removed_files)}\")\n        \n        click.echo(\"\\nüí° To reinitialize:\")\n        click.echo(\"   ‚Ä¢ Local mode: cidx init\")\n        click.echo(\"   ‚Ä¢ Remote mode: cidx init --remote <server> --username <user> --password <pass>\")\n        \n    except Exception as e:\n        click.echo(f\"‚ùå Error during uninstall: {str(e)}\")\n        click.echo(\"üí° You may need to manually remove files in .code-indexer/\")\n```\n\n## üß™ **Testing Requirements**\n\n### Unit Tests\n- ‚úÖ Remote status information collection and display\n- ‚úÖ Connection health testing logic\n- ‚úÖ Repository staleness analysis\n- ‚úÖ Remote uninstall file removal logic\n\n### Integration Tests\n- ‚úÖ End-to-end remote status with real server connection\n- ‚úÖ Status command error handling with network issues\n- ‚úÖ Remote uninstall process with confirmation flows\n- ‚úÖ Mode-specific command routing and behavior\n\n### User Experience Tests\n- ‚úÖ Status output clarity and usefulness for troubleshooting\n- ‚úÖ Uninstall confirmation process and safety\n- ‚úÖ Error message quality and actionable guidance\n- ‚úÖ Information completeness for repository management decisions\n\n## ‚öôÔ∏è **Implementation Pseudocode**\n\n### Remote Status Algorithm\n```\nFUNCTION display_remote_status(project_root):\n    config = load_remote_config(project_root)\n    \n    DISPLAY server_info(config.server_url, config.username)\n    DISPLAY repository_link_info(config.repository_link)\n    \n    # Test connection health\n    TRY:\n        test_server_connectivity(config)\n        test_authentication(config)\n        test_repository_access(config)\n    CATCH network_errors:\n        DISPLAY connection_troubleshooting_guidance()\n    \n    # Analyze repository staleness\n    local_branch = get_local_git_branch()\n    local_changes = count_local_changes()\n    \n    DISPLAY staleness_analysis(local_branch, config.repository_link.branch, local_changes)\n```\n\n### Remote Uninstall Algorithm\n```\nFUNCTION uninstall_remote_mode(project_root, confirm):\n    config_dir = project_root / \".code-indexer\"\n    files_to_remove = find_remote_config_files(config_dir)\n    \n    IF NOT confirm:\n        DISPLAY removal_preview(files_to_remove)\n        IF NOT user_confirms():\n            RETURN \"cancelled\"\n    \n    FOR file in files_to_remove:\n        TRY:\n            remove_file(file)\n        CATCH permission_error:\n            LOG error and continue\n    \n    IF config_dir.is_empty():\n        remove_directory(config_dir)\n    \n    DISPLAY success_message_with_reinit_guidance()\n```\n\n## ‚ö†Ô∏è **Edge Cases and Error Handling**\n\n### Network and Server Issues\n- Server unreachable -> show cached status info if available\n- Authentication failure -> guide user to credential update process\n- Repository access denied -> suggest contacting repository owner\n- Timeout during status check -> provide partial information with warnings\n\n### Configuration Edge Cases\n- Corrupted remote configuration -> offer reconfiguration options\n- Missing credential files -> guide through re-authentication\n- Invalid server URL format -> suggest URL correction\n- Partial configuration state -> determine what can be recovered\n\n### Git Repository Issues\n- Not in git repository -> skip git-related staleness analysis\n- Git repository in corrupted state -> handle gracefully with warnings\n- Detached HEAD state -> explain implications for remote linking\n- Repository with no commits -> handle edge case appropriately\n\n### File System Permissions\n- Cannot read configuration -> suggest permission fixes\n- Cannot write during uninstall -> provide manual removal instructions\n- Configuration directory locked -> retry with exponential backoff\n- Symbolic links in configuration path -> resolve correctly\n\n## üìä **Definition of Done**\n\n- ‚úÖ Remote status command displays comprehensive connection and repository information\n- ‚úÖ Connection health testing validates server, authentication, and repository access\n- ‚úÖ Repository staleness analysis helps users understand result relevance\n- ‚úÖ Remote uninstall safely removes configuration while preserving project files\n- ‚úÖ Error handling provides actionable guidance for all failure scenarios\n- ‚úÖ Comprehensive testing validates both happy path and error conditions\n- ‚úÖ User experience testing confirms information usefulness and clarity\n- ‚úÖ Integration with existing CLI framework and mode detection\n- ‚úÖ Documentation updated with remote-specific command behavior\n- ‚úÖ Code review validates implementation quality and user experience