# Story 4.5: Smart CIDX Lifecycle Management with Inactivity-Based Cleanup

## User Story
**As a** system administrator
**I want** CIDX containers to automatically stop after configurable inactivity period while preserving resume capability
**So that** resources are freed within 1 hour instead of 30 days while resume functionality remains available

## Business Value
Solves the critical resource waste problem where 55+ CIDX containers run indefinitely consuming ~10GB RAM, while maintaining full resume support. Smart lifecycle management stops containers after 1 hour of inactivity (default) but automatically restarts them when resume jobs arrive. Balances resource efficiency with resume capability.

## Current State Analysis

**CURRENT BEHAVIOR:**
- CIDX containers start when job begins execution
- Containers run FOREVER until 30-day retention cleanup
- Location: `/claude-batch-server/src/ClaudeBatchServer.Core/Services/JobService.cs`
  - HandleExecutionSuccessAsync (line 4642): Marks job complete, NO CIDX cleanup
  - CleanupExpiredJobsAsync (line 2275): Only cleanup after 30 days
- **RESOURCE WASTE:** 55 running containers consuming ~10GB RAM
- **CURRENT SYSTEM:** All containers from completed jobs still running

**CIDX CLEANUP CURRENTLY HAPPENS:**
1. Job cancelled: Immediate cleanup (CleanupCancelledJobAsync line 2242)
2. Job 30 days old: Retention cleanup (CleanupExpiredJobsAsync line 2275)
3. **MISSING:** Cleanup after job completion with inactivity timeout

**IMPLEMENTATION REQUIRED:**
- **BUILD** `CidxLifecycleManager` - NEW CLASS (manages container lifecycle)
- **BUILD** `InactivityTracker` - NEW CLASS (tracks last activity per job)
- **BUILD** Background timer job (runs every 1 minute)
- **MODIFY** `HandleExecutionSuccessAsync()` - Track job completion time
- **MODIFY** Resume logic - Restart CIDX if stopped, wait for ready
- **ADD** Configuration: `Cidx:InactivityTimeoutMinutes` (default 60)

**INTEGRATION POINTS:**
1. `JobService.HandleExecutionSuccessAsync()` (line 4642) - Start inactivity tracking
2. Resume job start - Check CIDX state, restart if needed
3. Background timer - Scan completed jobs, stop inactive CIDX
4. Configuration: appsettings.json

**FILES TO MODIFY:**
- `/claude-batch-server/src/ClaudeBatchServer.Core/Services/JobService.cs`

**FILES TO CREATE:**
- `/claude-batch-server/src/ClaudeBatchServer.Core/Services/CidxLifecycleManager.cs`
- `/claude-batch-server/src/ClaudeBatchServer.Core/Services/InactivityTracker.cs`

**EFFORT**: 1-2 days

## Technical Approach
Implement smart CIDX lifecycle that tracks job activity (completion, resume start, resume complete), stops CIDX containers after configurable inactivity period (default 1 hour), and automatically restarts CIDX when resume jobs arrive. Balances resource efficiency (containers stopped quickly) with resume functionality (workspace preserved, CIDX restarted on demand).

### Components
- `CidxLifecycleManager`: Coordinates CIDX start/stop lifecycle
- `InactivityTracker`: Tracks last activity timestamp per job
- Background timer: Runs every 1 minute, checks inactivity, stops CIDX
- Resume integration: Restarts CIDX before resuming job

## Core Design Principles

### **Activity Tracking**

**"Activity" = Latest of:**
1. Job completion timestamp (job.CompletedAt)
2. Resume start timestamp (job.ResumeStartedAt)
3. Resume completion timestamp (updated job.CompletedAt)

**CRITICAL RULE:** NEVER stop CIDX while job is running!

**Status Safety Check:**
```csharp
// ONLY stop if job is in terminal state
if (job.Status == JobStatus.Completed ||
    job.Status == JobStatus.Failed ||
    job.Status == JobStatus.Cancelled)
{
    // Safe to check inactivity
}
```

### **Inactivity Detection**

**Algorithm:**
```csharp
var lastActivity = GetLatestTimestamp(
    job.CompletedAt,
    job.ResumeStartedAt,
    job.Outputs.LastOrDefault()?.Timestamp  // Last resume completion
);

var inactiveDuration = DateTime.UtcNow - lastActivity;
var timeoutMinutes = _configuration.GetValue<int>("Cidx:InactivityTimeoutMinutes", 60);

if (inactiveDuration.TotalMinutes > timeoutMinutes)
{
    // Inactive - stop CIDX
    await StopCidxAsync(job);
}
```

### **CIDX Stop on Inactivity**

**Command:**
```bash
cidx stop --force-docker {workspace}
```

**Actions:**
1. Stop containers: cidx-{id}-qdrant, cidx-{id}-data-cleaner
2. Remove containers (--force-docker flag)
3. Clean up networks
4. Preserve workspace files (for resume)

**Mark Job:**
```csharp
job.CidxStatus = "stopped_inactive";  // Track why it stopped
job.Metadata["CidxStoppedAt"] = DateTime.UtcNow.ToString();
```

### **CIDX Restart on Resume**

**Resume Logic Enhancement:**
```csharp
// In resume job start:
if (job.Options.CidxAware && job.CidxStatus == "stopped_inactive")
{
    _logger.LogInformation("Restarting CIDX for resume job {JobId} (was stopped due to inactivity)", job.Id);

    // Run cidx start and WAIT for completion (no timeout)
    var startResult = await _agentExecutor.StartCidxAsync(job.CowPath, job.Username);

    if (startResult.ExitCode == 0)
    {
        job.CidxStatus = "ready";
        _logger.LogInformation("CIDX restarted successfully for job {JobId}", job.Id);
    }
    else
    {
        job.CidxStatus = "failed";
        _logger.LogWarning("CIDX restart failed for job {JobId}, continuing in degraded mode without CIDX", job.Id);
        // Continue without CIDX (degraded mode)
    }
}

// Then launch resume job
```

### **Background Timer Job**

**Implementation:**
```csharp
public class CidxInactivityCleanupService : BackgroundService
{
    private readonly IJobService _jobService;
    private readonly IConfiguration _configuration;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await CheckAndCleanupInactiveCidxAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in CIDX inactivity cleanup");
            }

            // Check every 1 minute
            await Task.Delay(TimeSpan.FromMinutes(1), stoppingToken);
        }
    }

    private async Task CheckAndCleanupInactiveCidxAsync()
    {
        var completedJobs = _jobService.GetAllJobs()
            .Where(j => j.Status == JobStatus.Completed &&
                       j.Options.CidxAware &&
                       j.CidxStatus == "ready");

        foreach (var job in completedJobs)
        {
            var lastActivity = GetLatestActivity(job);
            var inactiveDuration = DateTime.UtcNow - lastActivity;
            var timeoutMinutes = _configuration.GetValue<int>("Cidx:InactivityTimeoutMinutes", 60);

            if (inactiveDuration.TotalMinutes > timeoutMinutes)
            {
                _logger.LogInformation("Stopping CIDX for job {JobId} - inactive for {Minutes} minutes",
                    job.Id, inactiveDuration.TotalMinutes);

                await _agentExecutor.StopCidxAsync(job.CowPath, job.Username);
                job.CidxStatus = "stopped_inactive";
                job.Metadata["CidxStoppedAt"] = DateTime.UtcNow.ToString();
            }
        }
    }
}
```

**Runs:** Every 1 minute as BackgroundService

---

## Acceptance Criteria

```gherkin
# ========================================
# CATEGORY: Inactivity Tracking
# ========================================

Scenario: Job completion starts inactivity timer
  Given job completes successfully
  When job.Status set to Completed
  Then job.CompletedAt timestamp recorded
  And inactivity tracking begins
  And CIDX containers remain running

Scenario: Latest activity from multiple timestamps
  Given job completed at 10:00
  And resumed at 10:30
  And resume completed at 10:35
  When calculating inactivity
  Then latest timestamp is 10:35 (most recent activity)
  And inactivity measured from 10:35

Scenario: Running job never cleaned up
  Given job.Status = Running
  When inactivity check runs
  Then job skipped (not in terminal state)
  And CIDX remains untouched
  And CRITICAL: Never stop CIDX for running jobs

Scenario: Multiple resume extends activity
  Given job completed at 09:00
  And resumed at 09:30 (activity updated)
  And resumed again at 10:00 (activity updated)
  When inactivity check runs at 10:30
  Then last activity is 10:00
  And inactivity is 30 minutes (not 90 minutes)
  And CIDX not stopped yet (timeout is 60 minutes)

# ========================================
# CATEGORY: CIDX Stop After Inactivity
# ========================================

Scenario: CIDX stopped after timeout (1 hour default)
  Given job completed at 09:00
  And no resume activity since
  When background timer runs at 10:05
  Then inactivity = 65 minutes (exceeds 60-minute timeout)
  And cidx stop --force-docker executed
  And job.CidxStatus = "stopped_inactive"
  And containers stopped (resources freed)
  And workspace files preserved

Scenario: CIDX stop command with force-docker flag
  Given inactive job identified
  When cidx stop executed
  Then command is: cidx stop --force-docker {workspace}
  And --force-docker ensures container removal
  And both qdrant + data-cleaner containers stopped
  And Docker networks cleaned up

Scenario: CIDX stop failure handling
  Given cidx stop command fails
  When stop operation returns non-zero exit code
  Then error logged with output
  And job.CidxStatus = "stop_failed"
  And cleanup continues (non-critical failure)
  And next timer cycle retries

Scenario: Configurable inactivity timeout
  Given configuration: Cidx:InactivityTimeoutMinutes = 30
  And job completed 35 minutes ago
  When timer check runs
  Then timeout is 30 minutes (from config)
  And inactivity exceeds timeout
  And CIDX stopped

Scenario: Default timeout when not configured
  Given no Cidx:InactivityTimeoutMinutes in config
  When checking timeout value
  Then default is 60 minutes
  And system uses 60-minute inactivity window

# ========================================
# CATEGORY: Background Timer Job
# ========================================

Scenario: Timer runs every 1 minute
  Given CidxInactivityCleanupService started
  When service executes
  Then cleanup check runs
  And waits 1 minute
  And cleanup check runs again
  And continues until service stopped

Scenario: Timer scans only terminal-state jobs
  Given 10 completed jobs, 5 running jobs
  When timer executes
  Then only 10 completed jobs checked
  And 5 running jobs skipped (CRITICAL safety)
  And no interference with active jobs

Scenario: Timer handles multiple inactive jobs
  Given 20 jobs with CIDX inactive >1 hour
  When timer runs
  Then all 20 jobs processed
  And cidx stop executed for each
  And all 40 containers stopped (2 per job)
  And ~4GB RAM reclaimed

Scenario: Timer error handling
  Given timer execution encounters exception
  When error occurs
  Then error logged
  And timer continues (doesn't crash)
  And next cycle runs normally after 1 minute

# ========================================
# CATEGORY: CIDX Restart on Resume
# ========================================

Scenario: Resume with stopped CIDX
  Given job.Options.CidxAware = true
  And job.CidxStatus = "stopped_inactive"
  When resume job starts
  Then cidx start {workspace} executed
  And command waits for completion (no fixed timeout)
  And job.CidxStatus = "ready"
  And then resume job launches

Scenario: Resume with running CIDX
  Given job.Options.CidxAware = true
  And job.CidxStatus = "ready" (still running)
  When resume job starts
  Then NO cidx start needed
  And resume job launches immediately
  And resources already available

Scenario: Resume without CIDX awareness
  Given job.Options.CidxAware = false
  When resume job starts
  Then NO cidx operations
  And resume launches directly
  And CIDX lifecycle not involved

Scenario: cidx start success on resume
  Given stopped CIDX being restarted for resume
  When cidx start command completes successfully
  Then job.CidxStatus = "ready"
  And containers running (qdrant + data-cleaner)
  And resume job can proceed with CIDX

Scenario: cidx start failure on resume (degraded mode)
  Given stopped CIDX being restarted for resume
  When cidx start command fails (non-zero exit code)
  Then job.CidxStatus = "failed"
  And warning logged: "CIDX restart failed, continuing degraded"
  And resume job launches WITHOUT CIDX (degraded mode)
  And job completes (may have reduced functionality)

Scenario: cidx start waits for completion
  Given cidx start command executing
  When waiting for startup
  Then no fixed timeout applied
  And waits until command completes (success or failure)
  And then proceeds based on exit code

Scenario: Resume activity resets inactivity timer
  Given job CIDX stopped due to inactivity
  And CIDX restarted for resume at 11:00
  And resume completes at 11:05
  When inactivity check runs at 11:30
  Then last activity is 11:05 (resume completion)
  And inactivity is 25 minutes (not hours)
  And CIDX keeps running (below 60-minute timeout)

# ========================================
# CATEGORY: Configuration
# ========================================

Scenario: Inactivity timeout configuration
  Given appsettings.json contains:
    "Cidx": {
      "InactivityTimeoutMinutes": 60
    }
  When reading configuration
  Then timeout value is 60 minutes
  And used for all inactivity calculations

Scenario: Timer interval configuration
  Given cleanup timer configured
  When timer service starts
  Then check interval is 1 minute (fixed)
  And scans happen every 60 seconds
  And responsive to inactivity timeouts

Scenario: Configuration defaults
  Given Cidx:InactivityTimeoutMinutes not in config
  When reading timeout value
  Then default is 60 minutes
  And system behavior is predictable

# ========================================
# CATEGORY: Safety and Edge Cases
# ========================================

Scenario: Never stop CIDX for running jobs (CRITICAL SAFETY)
  Given job.Status = Running
  And job has been running for 5 hours (VERY LONG job)
  When inactivity timer checks job
  Then job skipped (not in terminal state)
  And CIDX untouched
  And 100% guarantee: running jobs protected

Scenario: Race condition - resume while stop in progress
  Given CIDX stop command executing for job
  When resume request arrives mid-stop
  Then resume waits for stop to complete
  And then executes cidx start
  And job processes normally

Scenario: Workspace without CIDX (non-CIDX jobs)
  Given job completed without CIDX (CidxAware = false)
  When inactivity timer runs
  Then job skipped (no CIDX to cleanup)
  And timer continues with next job

Scenario: CIDX already stopped (idempotent)
  Given job.CidxStatus = "stopped_inactive"
  When inactivity timer runs
  Then no cidx stop attempted (already stopped)
  And skip to next job (idempotent behavior)

# ========================================
# CATEGORY: Resource Reclamation Verification
# ========================================

Scenario: Container count after cleanup
  Given 55 running CIDX containers
  And 50 jobs completed >1 hour ago
  When cleanup timer processes all jobs
  Then cidx stop executed for 50 jobs
  And ~100 containers stopped (2 per job)
  And docker ps shows only active job containers
  And ~10GB RAM reclaimed

Scenario: Workspace preservation after CIDX stop
  Given CIDX stopped due to inactivity
  When workspace checked
  Then all files remain (git repo, output files, etc.)
  And only containers stopped (not workspace deleted)
  And resume remains possible

# ========================================
# CATEGORY: Logging and Observability
# ========================================

Scenario: CIDX stop logging
  Given CIDX being stopped for inactive job
  When stop executes
  Then log: "Stopping CIDX for job {JobId} - inactive for {Minutes} minutes"
  And cidx stop command output logged
  And job metadata updated with CidxStoppedAt timestamp

Scenario: CIDX restart logging
  Given CIDX being restarted for resume
  When cidx start executes
  Then log: "Restarting CIDX for resume job {JobId} (was stopped due to inactivity)"
  And cidx start command output logged
  And success/failure logged clearly

Scenario: Timer execution logging
  Given background timer runs
  When check cycle executes
  Then log: "CIDX inactivity check: {Checked} jobs checked, {Stopped} stopped"
  And summary logged every cycle
  And provides operational visibility

# ========================================
# CATEGORY: Error Handling
# ========================================

Scenario: cidx stop command failure
  Given cidx stop executed
  And command returns non-zero exit code
  When error occurs
  Then error logged with full output
  And job.CidxStatus = "stop_failed"
  And next timer cycle retries
  And system continues (non-critical)

Scenario: cidx start command failure on resume
  Given resume job needs CIDX
  And cidx start fails
  When error occurs
  Then warning logged
  And job.CidxStatus = "failed"
  And resume continues WITHOUT CIDX (degraded mode)
  And job may complete with reduced functionality

Scenario: User not found for cidx operation
  Given cidx stop/start needs user context
  And user not found in system
  When operation attempted
  Then error logged
  And operation skipped
  And job marked with error state

Scenario: Workspace path invalid
  Given job.CowPath is null or invalid
  When cidx operation attempted
  Then validation fails early
  And operation skipped
  And error logged

# ========================================
# CATEGORY: Workspace Retention (Separate Lifecycle)
# ========================================

Scenario: CIDX cleanup separate from workspace deletion
  Given job completed 2 hours ago
  When CIDX inactivity cleanup runs
  Then CIDX stopped (exceeds 1 hour timeout)
  And workspace files remain (not deleted)
  And 30-day retention policy still applies separately

Scenario: Workspace deletion after 30 days
  Given job created 31 days ago
  When retention cleanup runs (CleanupExpiredJobsAsync)
  Then workspace deleted entirely
  And CIDX uninstalled (if still running)
  And job removed from system
  And different lifecycle than CIDX cleanup

# ========================================
# CATEGORY: Testing Requirements
# ========================================

Scenario: Unit test inactivity calculation
  Given job completed at T=0
  And checked at T=65 minutes
  When inactivity calculated
  Then duration is 65 minutes
  And exceeds 60-minute threshold
  And stop triggered

Scenario: Integration test CIDX lifecycle
  Given real job completes
  When waiting 61 minutes (simulated via timestamp manipulation)
  Then cidx stop executed
  And containers actually stopped
  And workspace preserved

Scenario: E2E test resume after CIDX stopped
  Given job completed and CIDX stopped
  When resume API called
  Then cidx start executed
  And resume job waits for CIDX ready
  And resume proceeds with CIDX available
```

## Implementation Details

### InactivityTracker Class

**Location**: `/claude-batch-server/src/ClaudeBatchServer.Core/Services/InactivityTracker.cs`

```csharp
namespace ClaudeBatchServer.Core.Services;

public class InactivityTracker
{
    /// <summary>
    /// Gets the latest activity timestamp for a job.
    /// Activity = Latest of: completion, resume start, resume complete.
    /// CRITICAL: Only check for terminal-state jobs (never running jobs).
    /// </summary>
    public DateTime GetLatestActivity(Job job)
    {
        // Safety check: NEVER consider running jobs
        if (job.Status == JobStatus.Running ||
            job.Status == JobStatus.Queued ||
            job.Status == JobStatus.GitPulling ||
            job.Status == JobStatus.CidxIndexing ||
            job.Status == JobStatus.CidxReady ||
            job.Status == JobStatus.ResourceWaiting)
        {
            throw new InvalidOperationException($"Cannot track inactivity for job {job.Id} - job is not in terminal state (status: {job.Status})");
        }

        var timestamps = new List<DateTime>();

        // Completion timestamp
        if (job.CompletedAt.HasValue)
        {
            timestamps.Add(job.CompletedAt.Value);
        }

        // Resume start timestamp
        if (job.ResumeStartedAt.HasValue)
        {
            timestamps.Add(job.ResumeStartedAt.Value);
        }

        // Resume completion timestamps (from Outputs)
        if (job.Outputs.Any())
        {
            var lastOutput = job.Outputs
                .Where(o => o.CompletedAt.HasValue)
                .OrderByDescending(o => o.CompletedAt)
                .FirstOrDefault();

            if (lastOutput?.CompletedAt != null)
            {
                timestamps.Add(lastOutput.CompletedAt.Value);
            }
        }

        // Return latest
        if (!timestamps.Any())
        {
            throw new InvalidOperationException($"No activity timestamps found for job {job.Id}");
        }

        return timestamps.Max();
    }

    public TimeSpan GetInactiveDuration(Job job)
    {
        var lastActivity = GetLatestActivity(job);
        return DateTime.UtcNow - lastActivity;
    }

    public bool IsInactive(Job job, int timeoutMinutes)
    {
        return GetInactiveDuration(job).TotalMinutes > timeoutMinutes;
    }
}
```

### CidxLifecycleManager Class

**Location**: `/claude-batch-server/src/ClaudeBatchServer.Core/Services/CidxLifecycleManager.cs`

```csharp
namespace ClaudeBatchServer.Core.Services;

public class CidxLifecycleManager
{
    private readonly IClaudeCodeExecutor _executor;
    private readonly IJobPersistenceService _persistence;
    private readonly ILogger<CidxLifecycleManager> _logger;

    public async Task StopInactiveCidxAsync(Job job, TimeSpan inactiveDuration)
    {
        _logger.LogInformation("Stopping CIDX for job {JobId} - inactive for {Minutes:F1} minutes",
            job.Id, inactiveDuration.TotalMinutes);

        var result = await _executor.StopCidxAsync(job.CowPath, job.Username);

        if (result.ExitCode == 0)
        {
            job.CidxStatus = "stopped_inactive";
            job.Metadata["CidxStoppedAt"] = DateTime.UtcNow.ToString("O");
            await _persistence.SaveJobAsync(job);

            _logger.LogInformation("Successfully stopped CIDX for job {JobId}", job.Id);
        }
        else
        {
            job.CidxStatus = "stop_failed";
            _logger.LogWarning("Failed to stop CIDX for job {JobId}: {Output}", job.Id, result.Output);
        }
    }

    public async Task<bool> StartCidxForResumeAsync(Job job)
    {
        _logger.LogInformation("Restarting CIDX for resume job {JobId} (was stopped due to inactivity)", job.Id);

        var result = await _executor.StartCidxAsync(job.CowPath, job.Username);

        if (result.ExitCode == 0)
        {
            job.CidxStatus = "ready";
            _logger.LogInformation("CIDX restarted successfully for job {JobId}", job.Id);
            return true;
        }
        else
        {
            job.CidxStatus = "failed";
            _logger.LogWarning("CIDX restart failed for job {JobId}, continuing in degraded mode: {Output}",
                job.Id, result.Output);
            return false;  // Degraded mode - continue without CIDX
        }
    }
}
```

### Background Timer Service

**Location**: `/claude-batch-server/src/ClaudeBatchServer.Api/Services/CidxInactivityCleanupService.cs`

```csharp
namespace ClaudeBatchServer.Api.Services;

public class CidxInactivityCleanupService : BackgroundService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly IConfiguration _configuration;
    private readonly ILogger<CidxInactivityCleanupService> _logger;

    public CidxInactivityCleanupService(
        IServiceProvider serviceProvider,
        IConfiguration configuration,
        ILogger<CidxInactivityCleanupService> logger)
    {
        _serviceProvider = serviceProvider;
        _configuration = configuration;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        // Wait for startup to complete
        await Task.Delay(TimeSpan.FromMinutes(2), stoppingToken);

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _serviceProvider.CreateScope();
                var jobService = scope.ServiceProvider.GetRequiredService<IJobService>();
                var lifecycleManager = scope.ServiceProvider.GetRequiredService<CidxLifecycleManager>();
                var inactivityTracker = scope.ServiceProvider.GetRequiredService<InactivityTracker>();

                await CheckAndCleanupInactiveCidxAsync(jobService, lifecycleManager, inactivityTracker);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in CIDX inactivity cleanup cycle");
            }

            // Check every 1 minute
            await Task.Delay(TimeSpan.FromMinutes(1), stoppingToken);
        }
    }

    private async Task CheckAndCleanupInactiveCidxAsync(
        IJobService jobService,
        CidxLifecycleManager lifecycleManager,
        InactivityTracker inactivityTracker)
    {
        var timeoutMinutes = _configuration.GetValue<int>("Cidx:InactivityTimeoutMinutes", 60);

        // Get completed jobs with running CIDX
        var completedJobs = jobService.GetAllJobs()
            .Where(j => (j.Status == JobStatus.Completed ||
                        j.Status == JobStatus.Failed) &&
                       j.Options.CidxAware &&
                       j.CidxStatus == "ready")  // Only check if CIDX running
            .ToList();

        var stoppedCount = 0;

        foreach (var job in completedJobs)
        {
            try
            {
                if (inactivityTracker.IsInactive(job, timeoutMinutes))
                {
                    var inactiveDuration = inactivityTracker.GetInactiveDuration(job);
                    await lifecycleManager.StopInactiveCidxAsync(job, inactiveDuration);
                    stoppedCount++;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking/stopping CIDX for job {JobId}", job.Id);
                // Continue with next job
            }
        }

        if (stoppedCount > 0)
        {
            _logger.LogInformation("CIDX inactivity cleanup: {Checked} jobs checked, {Stopped} stopped",
                completedJobs.Count, stoppedCount);
        }
    }
}
```

### Resume Logic Enhancement

**Location**: `JobService.cs` - Resume job start

```csharp
// Before launching resume job:
if (job.Options.CidxAware && job.CidxStatus == "stopped_inactive")
{
    var cidxRestarted = await _cidxLifecycleManager.StartCidxForResumeAsync(job);

    if (!cidxRestarted)
    {
        _logger.LogWarning("Resume job {JobId} proceeding in degraded mode without CIDX", job.Id);
        // Continue anyway - degraded mode
    }

    // Reset inactivity tracking (resume counts as activity)
    job.ResumeStartedAt = DateTime.UtcNow;
    await _jobPersistenceService.SaveJobAsync(job);
}
```

## Testing Strategy

### Unit Tests
- `InactivityTracker.GetLatestActivity()` - timestamp logic
- `InactivityTracker.IsInactive()` - timeout comparison
- Configuration loading with defaults
- Terminal state validation (safety check)

### Integration Tests
- Background timer service lifecycle
- CIDX stop on inactivity (real cidx command)
- CIDX restart on resume (real cidx command)
- Activity timestamp updates

### E2E Tests
1. Complete job → wait 61 minutes → verify containers stopped
2. Resume stopped CIDX → verify restart → verify job succeeds
3. Long-running job (5 hours) → verify CIDX never stopped during execution
4. Multiple resumes → verify activity tracking extends each time

## Configuration

**appsettings.json:**
```json
{
  "Cidx": {
    "InactivityTimeoutMinutes": 60,
    "VoyageApiKey": "..."
  },
  "Jobs": {
    "RetentionDays": 30
  }
}
```

**Two Separate Lifecycles:**
1. **CIDX Containers:** Stopped after 1 hour inactivity (configurable)
2. **Workspace Files:** Deleted after 30 days (retention policy)

## Success Criteria

- ✅ CIDX containers stop after configurable inactivity (default 60 minutes)
- ✅ Background timer runs every 1 minute
- ✅ Resume restarts stopped CIDX automatically
- ✅ Resume waits for cidx start completion (no timeout)
- ✅ Degraded mode if cidx start fails (continues without CIDX)
- ✅ Running jobs NEVER have CIDX stopped (100% safety)
- ✅ Activity tracking uses latest of multiple timestamps
- ✅ Configuration externalized and defaults provided
- ✅ Clean build (0 warnings, 0 errors)
- ✅ Comprehensive test coverage (>90%)

## Dependencies

**Blocks**: None
**Blocked By**: None (can implement independently)
**Integrates With**:
- Story 2 (job completion)
- Resume functionality (existing)

**Shared Components**: Uses existing StopCidxAsync, UninstallCidxAsync, StartCidxAsync

## Estimated Effort

**Realistic Estimate**: 1-2 days

**Breakdown**:
- Day 1: InactivityTracker, CidxLifecycleManager, background timer service, tests
- Day 2: Resume integration, configuration, E2E testing, deployment verification

**Risk**: Low - straightforward implementation, clear requirements, existing CIDX commands work

---

## Value Proposition

**Current State:**
- 55 containers running indefinitely
- ~10GB RAM wasted
- 30-day wait for cleanup

**After Story 4.5:**
- Containers stopped after 1 hour idle
- ~10GB RAM reclaimed
- Resume still works (CIDX restarted on demand)
- Configurable timeout (tune to your needs)

**ROI**: High - simple implementation, significant resource savings, maintains resume capability
