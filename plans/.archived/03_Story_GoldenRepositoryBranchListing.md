# User Story: Golden Repository Branch Listing

## 📋 **User Story**

As a **CIDX remote client**, I want to **retrieve the list of available branches for a golden repository before activation**, so that **I can make intelligent branch selection decisions during repository linking**.

## 🎯 **Business Value**

Enables smart repository linking by providing branch information before committing to repository activation. Users can see available branches and make informed decisions about which branch to link to, supporting intelligent fallback strategies when exact branch matches don't exist.

## 📝 **Acceptance Criteria**

### Given: Golden Repository Branch Enumeration
**When** I call `GET /api/repos/golden/{alias}/branches`  
**Then** the endpoint returns all available branches for the golden repository  
**And** includes branch metadata (name, type, last commit info)  
**And** handles repositories with hundreds of branches efficiently  
**And** returns empty list for repositories with no branches gracefully  

### Given: Branch Information Detail
**When** I receive the branch listing response  
**Then** each branch includes name and basic metadata  
**And** identifies default/primary branch if available  
**And** provides last commit timestamp for branch recency assessment  
**And** includes branch type information (feature, release, hotfix patterns)  

### Given: Authentication and Authorization  
**When** I request golden repository branch information  
**Then** the endpoint requires valid JWT authentication  
**And** respects repository access permissions  
**And** only returns branches for repositories user can access  
**And** provides clear error messages for unauthorized repositories  

### Given: Performance and Caching
**When** I query branch information repeatedly  
**Then** the endpoint responds within 3 seconds for repositories with many branches  
**And** implements appropriate caching to avoid repeated git operations  
**And** handles concurrent requests efficiently  
**And** provides consistent results for the same repository  

## 🏗️ **Technical Implementation**

### API Endpoint Design
```python
@app.get("/api/repos/golden/{alias}/branches")
async def list_golden_repository_branches(
    alias: str,
    current_user: User = Depends(get_current_user)
) -> GoldenRepositoryBranchesResponse:
    \"\"\"\n    List available branches for golden repository.\n    \n    Args:\n        alias: Golden repository alias\n        current_user: Authenticated user from JWT token\n        \n    Returns:\n        GoldenRepositoryBranchesResponse with branch information\n    \"\"\"\n    # Validate user access to golden repository\n    golden_repo = await get_golden_repository(alias, current_user)\n    if not golden_repo:\n        raise HTTPException(status_code=404, detail="Golden repository not found")\n    \n    # Get branch information from git repository\n    branches = await get_repository_branches(golden_repo)\n    \n    return GoldenRepositoryBranchesResponse(\n        repository_alias=alias,\n        total_branches=len(branches),\n        default_branch=golden_repo.default_branch,\n        branches=branches\n    )\n```\n\n### Response Data Models
```python\nclass BranchInfo(BaseModel):\n    name: str\n    is_default: bool\n    last_commit_hash: Optional[str]\n    last_commit_timestamp: Optional[datetime]\n    last_commit_author: Optional[str]\n    branch_type: Optional[str]  # feature, release, hotfix, main, develop\n    \nclass GoldenRepositoryBranchesResponse(BaseModel):\n    repository_alias: str\n    total_branches: int\n    default_branch: Optional[str]\n    branches: List[BranchInfo]\n    retrieved_at: datetime\n```\n\n### Branch Information Collection\n```python\nasync def get_repository_branches(golden_repo: GoldenRepository) -> List[BranchInfo]:\n    \"\"\"\n    Efficiently collect branch information from git repository.\n    \n    Returns:\n        List of BranchInfo with metadata for intelligent client matching\n    \"\"\"\n    branches = []\n    \n    # Use GitTopologyService for efficient branch enumeration\n    git_service = GitTopologyService(golden_repo.repository_path)\n    \n    # Get all branches with commit info\n    raw_branches = git_service.get_all_branches_with_commits()\n    \n    for branch_data in raw_branches:\n        branch_info = BranchInfo(\n            name=branch_data['name'],\n            is_default=(branch_data['name'] == golden_repo.default_branch),\n            last_commit_hash=branch_data.get('commit_hash'),\n            last_commit_timestamp=parse_git_timestamp(branch_data.get('timestamp')),\n            last_commit_author=branch_data.get('author'),\n            branch_type=classify_branch_type(branch_data['name'])\n        )\n        branches.append(branch_info)\n    \n    # Sort by recency and importance (default branch first)\n    return sort_branches_by_relevance(branches)\n```\n\n### Branch Classification Logic\n```python\ndef classify_branch_type(branch_name: str) -> Optional[str]:\n    \"\"\"\n    Classify branch based on naming patterns for intelligent matching.\n    \n    Returns:\n        Branch type category for client-side matching logic\n    \"\"\"\n    branch_lower = branch_name.lower()\n    \n    # Main/primary branches\n    if branch_lower in ['main', 'master', 'develop', 'development']:\n        return 'primary'\n    \n    # Release branches\n    if branch_lower.startswith(('release/', 'rel/', 'v')):\n        return 'release'\n    \n    # Hotfix branches\n    if branch_lower.startswith(('hotfix/', 'fix/', 'patch/')):\n        return 'hotfix'\n    \n    # Feature branches\n    if branch_lower.startswith(('feature/', 'feat/', 'features/')):\n        return 'feature'\n    \n    return 'other'\n```\n\n## 🧪 **Testing Requirements**\n\n### Unit Tests\n- ✅ Branch enumeration for repositories with various branch counts\n- ✅ Branch classification logic for different naming patterns\n- ✅ Authentication and authorization validation\n- ✅ Error handling for missing or inaccessible repositories\n\n### Integration Tests\n- ✅ End-to-end API requests with real golden repositories\n- ✅ Git repository branch extraction and metadata collection\n- ✅ Response format validation and consistency\n- ✅ Performance testing with repositories containing many branches\n\n### Performance Tests\n- ✅ Response time for repositories with 100+ branches\n- ✅ Concurrent request handling without git lock conflicts\n- ✅ Caching effectiveness for repeated branch queries\n- ✅ Memory usage with large branch datasets\n\n### Edge Case Tests\n- ✅ Repositories with no branches (empty repositories)\n- ✅ Repositories with unusual branch names (special characters)\n- ✅ Repositories with very old branches (timestamp edge cases)\n- ✅ Repositories with detached HEAD state\n\n## ⚙️ **Implementation Pseudocode**\n\n### Efficient Branch Collection Algorithm\n```\nFUNCTION get_repository_branches(golden_repo):\n    branches = []\n    \n    # Use git for-each-ref for efficient branch enumeration\n    git_command = [\n        'git', 'for-each-ref', \n        '--format=%(refname:short)|%(objectname)|%(committerdate:iso)|%(authorname)',\n        'refs/heads/'\n    ]\n    \n    TRY:\n        output = execute_git_command(git_command, golden_repo.path)\n        \n        FOR line in output.split('\\n'):\n            IF line.strip():\n                name, commit_hash, timestamp, author = line.split('|')\n                \n                branch = BranchInfo(\n                    name=name,\n                    is_default=(name == golden_repo.default_branch),\n                    last_commit_hash=commit_hash,\n                    last_commit_timestamp=parse_timestamp(timestamp),\n                    last_commit_author=author,\n                    branch_type=classify_branch_type(name)\n                )\n                \n                branches.append(branch)\n    \n    EXCEPT GitError:\n        LOG error and return empty list\n    \n    RETURN sort_branches_by_relevance(branches)\n```\n\n### Branch Relevance Sorting\n```\nFUNCTION sort_branches_by_relevance(branches):\n    # Priority order for intelligent client matching:\n    # 1. Default branch (highest priority)\n    # 2. Primary branches (main, develop)\n    # 3. Recent branches (by last commit)\n    # 4. Release branches\n    # 5. Feature branches\n    # 6. Other branches\n    \n    RETURN sorted(branches, key=lambda b: (\n        not b.is_default,                    # Default branch first\n        b.branch_type != 'primary',          # Primary branches next\n        -b.last_commit_timestamp.timestamp(), # Recent commits first\n        b.branch_type == 'other',            # Categorized branches before 'other'\n        b.name                               # Alphabetical within same category\n    ))\n```\n\n## ⚠️ **Edge Cases and Error Handling**\n\n### Repository Access Issues\n- Golden repository not found -> 404 with clear error message\n- User lacks repository access -> 403 with permission guidance\n- Repository path inaccessible -> 500 with system error details\n- Git repository corrupted -> graceful degradation with warning\n\n### Git Operation Failures\n- Git command timeout -> return cached data if available\n- Repository locked during branch enumeration -> retry with backoff\n- Detached HEAD state -> handle gracefully, include HEAD info\n- Empty repository -> return empty branch list with appropriate metadata\n\n### Performance Considerations\n- Cache branch information with TTL (5 minutes) to reduce git operations\n- Limit branch enumeration to reasonable number (e.g., 1000 branches)\n- Use git for-each-ref for efficient batch branch information retrieval\n- Implement request timeout to prevent hanging on slow repositories\n\n### Data Consistency\n- Handle branch creation/deletion during enumeration gracefully\n- Ensure timestamp parsing works across different git versions\n- Normalize branch names for consistent client-side matching\n- Validate branch metadata before including in response\n\n## 📊 **Definition of Done**\n\n- ✅ API endpoint implemented and tested with comprehensive coverage\n- ✅ Branch enumeration works efficiently for repositories with many branches\n- ✅ Branch classification logic handles common naming patterns\n- ✅ Authentication and authorization properly enforced\n- ✅ Response format includes all required branch metadata\n- ✅ Performance testing confirms <3 second response times\n- ✅ Caching implementation reduces redundant git operations\n- ✅ Error handling covers all identified edge cases\n- ✅ Integration tests validate end-to-end branch listing functionality\n- ✅ API documentation updated with endpoint specification\n- ✅ Code review completed with focus on git operation efficiency