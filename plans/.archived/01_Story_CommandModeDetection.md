# User Story: Command Mode Detection

## 📋 **User Story**

As a **CIDX user**, I want **the CLI to automatically detect whether I'm in local or remote mode**, so that **commands are routed to the appropriate execution path without me having to specify the mode explicitly**.

## 🎯 **Business Value**

Provides seamless user experience by eliminating the need for mode-specific command variations. Users can use familiar commands regardless of whether they're working with local containers or remote repositories, with automatic intelligent routing based on project configuration.

## 📝 **Acceptance Criteria**

### Given: Local Mode Detection
**When** I run any CIDX command in a directory with local configuration  
**Then** the system detects "local" mode automatically  
**And** routes commands through local execution paths  
**And** uses existing container and indexing infrastructure  
**And** preserves all current local functionality  

### Given: Remote Mode Detection  
**When** I run any CIDX command in a directory with remote configuration  
**Then** the system detects "remote" mode automatically  
**And** routes commands through remote API execution paths  
**And** uses encrypted credentials for authentication  
**And** connects to configured remote server  

### Given: Uninitialized Repository Detection
**When** I run commands in a directory without CIDX configuration  
**Then** the system detects "uninitialized" mode  
**And** provides clear guidance on initialization options  
**And** suggests both local and remote initialization commands  
**And** doesn't attempt to execute operations that require initialization  

### Given: Configuration Validation
**When** I run commands with existing configuration  
**Then** the system validates configuration integrity  
**And** handles corrupted configuration files gracefully  
**And** provides clear error messages for configuration issues  
**And** suggests recovery steps for broken configurations  

## 🏗️ **Technical Implementation**

### Mode Detection Core Logic
```python\nclass CommandModeDetector:\n    def __init__(self, project_root: Path):\n        self.project_root = project_root\n        self.config_dir = project_root / \".code-indexer\"\n    \n    def detect_mode(self) -> Literal[\"local\", \"remote\", \"uninitialized\"]:\n        \"\"\"\n        Detect current operational mode based on configuration files.\n        \n        Returns:\n            Mode string for command routing decisions\n        \"\"\"\n        if not self.config_dir.exists():\n            return \"uninitialized\"\n        \n        # Check for remote configuration first (more specific)\n        remote_config_path = self.config_dir / \".remote-config\"\n        if remote_config_path.exists() and self._validate_remote_config(remote_config_path):\n            return \"remote\"\n        \n        # Check for local configuration\n        local_config_path = self.config_dir / \"config.toml\"\n        if local_config_path.exists() and self._validate_local_config(local_config_path):\n            return \"local\"\n        \n        return \"uninitialized\"\n    \n    def _validate_remote_config(self, config_path: Path) -> bool:\n        \"\"\"Validate remote configuration integrity.\"\"\"\n        try:\n            with open(config_path, 'r') as f:\n                config = json.load(f)\n            \n            # Required fields for remote mode\n            required_fields = ['server_url', 'encrypted_credentials', 'repository_link']\n            return all(field in config for field in required_fields)\n            \n        except (json.JSONDecodeError, IOError, KeyError):\n            return False\n    \n    def _validate_local_config(self, config_path: Path) -> bool:\n        \"\"\"Validate local configuration integrity.\"\"\"\n        try:\n            with open(config_path, 'rb') as f:\n                toml.load(f)\n            return True\n            \n        except (toml.TomlDecodeError, IOError):\n            return False\n```\n\n### CLI Integration with Click Context\n```python\n@cli.group()\n@click.option('--project-root', type=click.Path(exists=True, path_type=Path))\n@click.pass_context\ndef main(ctx, project_root: Optional[Path]):\n    \"\"\"Main CLI entry point with automatic mode detection.\"\"\"\n    if project_root is None:\n        project_root = find_project_root(Path.cwd())\n    \n    # Detect mode and store in Click context\n    detector = CommandModeDetector(project_root)\n    mode = detector.detect_mode()\n    \n    # Store mode and configuration in context for command access\n    ctx.ensure_object(dict)\n    ctx.obj['mode'] = mode\n    ctx.obj['project_root'] = project_root\n    ctx.obj['detector'] = detector\n```\n\n### Command Routing Implementation\n```python\n@cli.command(\"query\")\n@click.argument('query_text')\n@click.option('--limit', default=10)\n@click.pass_context\ndef query_command(ctx, query_text: str, limit: int):\n    \"\"\"Execute query with automatic mode-based routing.\"\"\"\n    mode = ctx.obj['mode']\n    project_root = ctx.obj['project_root']\n    \n    if mode == \"uninitialized\":\n        raise ClickException(\n            \"Repository not initialized. Use 'cidx init' for local mode or \"\n            \"'cidx init --remote <server> --username <user> --password <pass>' for remote mode.\"\n        )\n    elif mode == \"local\":\n        return execute_local_query(query_text, limit, project_root)\n    elif mode == \"remote\":\n        return execute_remote_query(query_text, limit, project_root)\n```\n\n### Project Root Discovery\n```python\ndef find_project_root(start_path: Path) -> Path:\n    \"\"\"\n    Walk up directory tree to find CIDX configuration, similar to git.\n    \n    Returns:\n        Path to directory containing .code-indexer configuration\n    \"\"\"\n    current_path = start_path.resolve()\n    \n    while current_path != current_path.parent:\n        config_dir = current_path / \".code-indexer\"\n        if config_dir.exists():\n            return current_path\n        current_path = current_path.parent\n    \n    # If no configuration found, use current directory as project root\n    return start_path\n```\n\n## 🧪 **Testing Requirements**\n\n### Unit Tests\n- ✅ Mode detection with various configuration file combinations\n- ✅ Configuration validation for both local and remote formats\n- ✅ Project root discovery walking up directory tree\n- ✅ Error handling for corrupted or invalid configuration files\n\n### Integration Tests\n- ✅ Click context integration with mode detection\n- ✅ Command routing based on detected mode\n- ✅ End-to-end mode detection with real configuration files\n- ✅ Configuration validation with malformed files\n\n### Edge Case Tests\n- ✅ No configuration directory exists\n- ✅ Configuration directory exists but is empty\n- ✅ Both local and remote configuration files present (remote takes precedence)\n- ✅ Configuration files with incorrect permissions\n- ✅ Symbolic links in configuration directory structure\n\n### Performance Tests\n- ✅ Mode detection performance with deep directory trees\n- ✅ Configuration validation performance with large config files\n- ✅ Memory usage during project root discovery\n- ✅ Concurrent mode detection operations\n\n## ⚙️ **Implementation Pseudocode**\n\n### Mode Detection Algorithm\n```\nFUNCTION detect_mode(project_root):\n    config_dir = project_root / \".code-indexer\"\n    \n    IF NOT config_dir.exists():\n        RETURN \"uninitialized\"\n    \n    # Check for remote configuration (higher priority)\n    remote_config = config_dir / \".remote-config\"\n    IF remote_config.exists():\n        IF validate_remote_config(remote_config):\n            RETURN \"remote\"\n    \n    # Check for local configuration\n    local_config = config_dir / \"config.toml\"\n    IF local_config.exists():\n        IF validate_local_config(local_config):\n            RETURN \"local\"\n    \n    RETURN \"uninitialized\"\n```\n\n### Command Routing Algorithm\n```\nFUNCTION route_command(command_name, arguments, context):\n    mode = context.mode\n    \n    MATCH mode:\n        CASE \"local\":\n            RETURN execute_local_command(command_name, arguments)\n        CASE \"remote\":\n            IF command_name IN remote_compatible_commands:\n                RETURN execute_remote_command(command_name, arguments)\n            ELSE:\n                RAISE CommandNotAvailableError(command_name, mode)\n        CASE \"uninitialized\":\n            IF command_name IN [\"init\", \"help\", \"version\"]:\n                RETURN execute_command(command_name, arguments)\n            ELSE:\n                RAISE UninitializedRepositoryError()\n```\n\n## ⚠️ **Edge Cases and Error Handling**\n\n### Configuration File Issues\n- Corrupted JSON/TOML files -> clear error message with file path\n- Missing required fields -> specific error about which fields are missing\n- File permission issues -> suggest permission fixes\n- Concurrent file access -> retry logic with backoff\n\n### Directory Structure Issues\n- .code-indexer directory but no config files -> treat as uninitialized\n- Configuration files in parent directories -> walk up tree like git\n- Symbolic links in path -> resolve links properly\n- Network mounted directories -> handle potential access delays\n\n### Mode Transition Scenarios\n- Switching from local to remote -> clear guidance on migration\n- Multiple configuration files -> clear precedence rules (remote > local)\n- Configuration validation failures -> suggest specific recovery steps\n- Project root detection failures -> fall back to current directory\n\n### Performance Considerations\n- Cache mode detection results during single command execution\n- Limit directory tree walking to reasonable depth (e.g., 20 levels)\n- Use efficient file existence checks\n- Minimize file I/O during mode detection\n\n## 📊 **Definition of Done**\n\n- ✅ CommandModeDetector class implemented with comprehensive mode detection\n- ✅ Configuration validation for both local and remote formats\n- ✅ Click CLI integration with mode stored in context\n- ✅ Project root discovery with directory tree walking\n- ✅ Command routing logic based on detected mode\n- ✅ Error handling for all configuration file edge cases\n- ✅ Comprehensive test coverage including unit and integration tests\n- ✅ Performance testing confirms efficient mode detection\n- ✅ Clear error messages for all failure scenarios\n- ✅ Documentation updated with mode detection behavior\n- ✅ Code review validates architecture and implementation quality