name: Release MCP Bridge Binaries

on:
  push:
    tags:
      - "v*"  # Trigger on version tags (e.g., v1.0.0)
  workflow_dispatch:  # Allow manual triggering

permissions:
  contents: write  # Required for creating releases and uploading assets

jobs:
  build-binaries:
    name: Build ${{ matrix.platform }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-22.04
            platform: linux-x64
          - os: macos-13  # Intel Mac
            platform: darwin-x64
          - os: macos-latest  # Apple Silicon Mac (M1/M2)
            platform: darwin-arm64
          - os: windows-latest
            platform: windows-x64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.9"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller
          pip install -e .

      - name: Build binary
        run: |
          python scripts/build_binary.py build --output-dir dist --platform ${{ matrix.platform }}

      - name: Get version
        id: get_version
        shell: bash
        run: |
          # Always extract version from source code for consistency
          VERSION=$(python3 -c "import sys; sys.path.insert(0, 'src'); from code_indexer import __version__; print(__version__)")
          echo "Version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Verify binary
        run: |
          python scripts/build_binary.py verify --binary dist/mcpb-${{ matrix.platform }}${{ matrix.platform == 'windows-x64' && '.exe' || '' }} --version ${{ steps.get_version.outputs.version }}

      - name: Create bundle
        run: |
          python scripts/build_binary.py create-bundle --platform ${{ matrix.platform }} --binary dist/mcpb-${{ matrix.platform }}${{ matrix.platform == 'windows-x64' && '.exe' || '' }} --version ${{ steps.get_version.outputs.version }} --output-dir dist

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: mcpb-${{ matrix.platform }}
          path: dist/mcpb-${{ matrix.platform }}.mcpb
          retention-days: 1

  validate-installer-script:
    name: Validate NSIS Installer Script
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.9"

      - name: Install test dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest
          pip install -e .

      - name: Run installer script validation tests
        run: |
          pytest tests/installer/test_nsis_installer.py -v

  build-windows-installer:
    name: Build Windows Installer
    needs: [build-binaries, validate-installer-script]
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Windows binary artifact
        uses: actions/download-artifact@v4
        with:
          name: mcpb-windows-x64
          path: artifacts

      - name: Extract Windows binary from bundle
        shell: pwsh
        run: |
          # Extract mcpb-windows-x64.exe from the .mcpb bundle (ZIP)
          Expand-Archive -Path artifacts/mcpb-windows-x64.mcpb -DestinationPath temp-extract -Force
          Copy-Item temp-extract/server/mcpb-windows-x64.exe scripts/installer/ -Force
          Write-Host "Binary extracted to scripts/installer/mcpb-windows-x64.exe"

      - name: Install NSIS
        shell: pwsh
        run: |
          Write-Host "Installing NSIS via chocolatey..."
          choco install nsis -y
          Write-Host "NSIS installation complete"

      - name: Download and Install NScurl Plugin
        shell: pwsh
        run: |
          Write-Host "Downloading NScurl plugin..."
          $nscurlUrl = "https://github.com/negrutiu/nsis-nscurl/releases/download/v25.11.11.274/NScurl.zip"
          Invoke-WebRequest -Uri $nscurlUrl -OutFile NScurl.zip

          Write-Host "Extracting NScurl plugin..."
          Expand-Archive -Path NScurl.zip -DestinationPath NScurl-extract -Force

          Write-Host "Listing extracted contents..."
          Get-ChildItem -Path NScurl-extract -Recurse | Select-Object FullName

          Write-Host "Installing NScurl plugin files..."
          $nsisDir = "C:\Program Files (x86)\NSIS"

          # Find the Plugins directory (may be at root or in subdirectory)
          $pluginsDir = Get-ChildItem -Path NScurl-extract -Recurse -Directory -Filter "Plugins" | Select-Object -First 1
          if ($pluginsDir) {
              Copy-Item "$($pluginsDir.FullName)\x86-unicode\NScurl.dll" "$nsisDir\Plugins\x86-unicode\" -Force
              Copy-Item "$($pluginsDir.FullName)\x86-ansi\NScurl.dll" "$nsisDir\Plugins\x86-ansi\" -Force
              Write-Host "NScurl DLLs installed"
          } else {
              Write-Error "Could not find Plugins directory in NScurl archive"
              exit 1
          }

          # Find the Include directory
          $includeDir = Get-ChildItem -Path NScurl-extract -Recurse -Directory -Filter "Include" | Select-Object -First 1
          if ($includeDir) {
              Copy-Item "$($includeDir.FullName)\NScurl.nsh" "$nsisDir\Include\" -Force
              Write-Host "NScurl.nsh installed"
          } else {
              Write-Host "Warning: Include directory not found, NScurl.nsh may already exist or not be required"
          }

          Write-Host "NScurl plugin installed"

      - name: Download and Install nsJSON Plugin
        shell: pwsh
        run: |
          Write-Host "Downloading nsJSON plugin..."
          $nsjsonUrl = "https://github.com/Pieter-Dewachter/nsJSON/releases/download/v1.1.1.1/NsJSON-1.1.1.1.zip"
          Invoke-WebRequest -Uri $nsjsonUrl -OutFile nsJSON.zip

          Write-Host "Extracting nsJSON plugin..."
          Expand-Archive -Path nsJSON.zip -DestinationPath nsJSON-extract -Force

          Write-Host "Listing extracted contents..."
          Get-ChildItem -Path nsJSON-extract -Recurse | Select-Object FullName

          Write-Host "Installing nsJSON plugin files..."
          $nsisDir = "C:\Program Files (x86)\NSIS"

          # Find the Plugins directory (may be at root or in subdirectory)
          $pluginsDir = Get-ChildItem -Path nsJSON-extract -Recurse -Directory -Filter "Plugins" | Select-Object -First 1
          if ($pluginsDir) {
              Copy-Item "$($pluginsDir.FullName)\x86-unicode\nsJSON.dll" "$nsisDir\Plugins\x86-unicode\" -Force
              Copy-Item "$($pluginsDir.FullName)\x86-ansi\nsJSON.dll" "$nsisDir\Plugins\x86-ansi\" -Force
              Write-Host "nsJSON DLLs installed"
          } else {
              Write-Error "Could not find Plugins directory in nsJSON archive"
              exit 1
          }

          Write-Host "nsJSON plugin installed"

      - name: Verify makensis availability
        shell: pwsh
        run: |
          $makensis = "C:\Program Files (x86)\NSIS\makensis.exe"
          if (Test-Path $makensis) {
            Write-Host "makensis found at: $makensis"
            & $makensis /VERSION
          } else {
            Write-Error "makensis not found at expected location"
            exit 1
          }

      - name: Compile NSIS Installer
        shell: pwsh
        run: |
          Write-Host "Compiling NSIS installer..."
          $makensis = "C:\Program Files (x86)\NSIS\makensis.exe"
          $nsiScript = "scripts\installer\mcpb-installer.nsi"

          & $makensis /V4 $nsiScript

          if ($LASTEXITCODE -ne 0) {
            Write-Error "NSIS compilation failed with exit code: $LASTEXITCODE"
            exit 1
          }

          Write-Host "Installer compilation successful"

      - name: Rename installer output
        shell: pwsh
        run: |
          # NSIS outputs mcpb-installer.exe, rename to mcpb-windows-x64-setup.exe
          Move-Item scripts\installer\mcpb-installer.exe scripts\installer\mcpb-windows-x64-setup.exe -Force
          Write-Host "Installer renamed to mcpb-windows-x64-setup.exe"

      - name: Verify installer exists
        shell: pwsh
        run: |
          if (-not (Test-Path "scripts\installer\mcpb-windows-x64-setup.exe")) {
            Write-Error "Installer not found: mcpb-windows-x64-setup.exe"
            exit 1
          }
          $size = (Get-Item "scripts\installer\mcpb-windows-x64-setup.exe").Length
          Write-Host "Installer verified: mcpb-windows-x64-setup.exe ($size bytes)"

      - name: Test nsJSON directly (no NScurl)
        shell: pwsh
        run: |
          Write-Host "Testing nsJSON::Set /value + Get pattern (same as installer config creation)..."

          # Test nsJSON in isolation - focus on Set/Get roundtrip functionality
          # Don't check intermediate errors - just verify the final Get works
          $testScript = @'
          !addplugindir "C:\Program Files (x86)\NSIS\Plugins\x86-unicode"
          Unicode true

          Name "nsJSON Direct Test"
          OutFile "nsjson-test.exe"
          InstallDir "$TEMP\nsjsontest"
          SilentInstall silent

          Section
            ; Initialize empty JSON object and set key/value pairs
            ; Don't check errors - just verify the final Get works
            nsJSON::Set /value `{}`
            nsJSON::Set `access_token` /value `"test_token_123"`
            nsJSON::Set `refresh_token` /value `"refresh_456"`

            ; Now verify Get returns the correct value
            nsJSON::Get `access_token` /end
            Pop $0

            ; Debug: Write to temp file what we got
            FileOpen $1 "$TEMP\nsjson-result.txt" w
            FileWrite $1 "Got: $0"
            FileClose $1

            ; Check if we got the expected value
            StrCmp $0 "test_token_123" success fail

          success:
            SetErrorLevel 0
            Goto done

          fail:
            SetErrorLevel 1

          done:
          SectionEnd
          '@

          $testScript | Out-File -FilePath "nsjson-test.nsi" -Encoding ASCII
          $makensis = "C:\Program Files (x86)\NSIS\makensis.exe"
          & $makensis /V2 nsjson-test.nsi

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to compile nsJSON test"
            exit 1
          }

          $process = Start-Process -FilePath "nsjson-test.exe" -Wait -NoNewWindow -PassThru
          Write-Host "nsJSON direct test exit code: $($process.ExitCode)"

          switch ($process.ExitCode) {
            0 { Write-Host "SUCCESS: nsJSON Set/Get roundtrip verified!" }
            1 { Write-Error "FAILED: Get returned incorrect value (expected 'test_token_123')"; exit 1 }
            default { Write-Error "FAILED: Unknown error $($process.ExitCode)"; exit 1 }
          }

      - name: Test nsJSON file loading (simple JSON file)
        shell: pwsh
        run: |
          Write-Host "Testing nsJSON /file loading with simple hand-written JSON..."

          # Test nsJSON /file with a simple JSON file written by NSIS
          # This isolates the file parsing from NScurl
          $testScript = @'
          !addplugindir "C:\Program Files (x86)\NSIS\Plugins\x86-unicode"
          !include "LogicLib.nsh"
          Unicode true

          Name "JSON File Load Test"
          OutFile "json-file-test.exe"
          InstallDir "$TEMP\jsontest"
          SilentInstall silent

          Section
            SetOutPath $INSTDIR

            StrCpy $1 "$TEMP\test_simple.json"
            StrCpy $9 "$TEMP\json_file_debug.txt"

            ; Write a simple single-line JSON file (like CIDX auth response)
            FileOpen $7 $1 w
            FileWrite $7 `{"access_token":"test123","refresh_token":"refresh456"}`
            FileClose $7

            ; Debug
            FileOpen $8 $9 w
            FileWrite $8 "JSON file created at: $1$\r$\n"

            ; Verify file was created
            IfFileExists "$1" +1 fail_file
            FileWrite $8 "File exists: YES$\r$\n"

            ; Load JSON from file
            ClearErrors
            nsJSON::Set /file "$1"
            ${If} ${Errors}
              FileWrite $8 "FAIL: nsJSON::Set /file returned error$\r$\n"
              FileClose $8
              SetErrorLevel 4
              Goto done
            ${EndIf}
            FileWrite $8 "nsJSON::Set /file succeeded$\r$\n"

            ; Get access_token
            nsJSON::Get "access_token" /END
            Pop $2
            FileWrite $8 "nsJSON::Get access_token returned: [$2]$\r$\n"

            ; Verify we got the expected value
            StrCmp $2 "test123" +1 fail_get

            ; Success
            FileWrite $8 "SUCCESS: Got expected value$\r$\n"
            FileClose $8
            Delete "$1"
            SetErrorLevel 0
            Goto done

          fail_file:
            FileWrite $8 "FAIL: File not created$\r$\n"
            FileClose $8
            SetErrorLevel 2
            Goto done

          fail_get:
            FileWrite $8 "FAIL: Get returned wrong value$\r$\n"
            FileClose $8
            SetErrorLevel 3

          done:
          SectionEnd
          '@

          $testScript | Out-File -FilePath "json-file-test.nsi" -Encoding ASCII
          $makensis = "C:\Program Files (x86)\NSIS\makensis.exe"
          & $makensis /V2 json-file-test.nsi

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to compile json file test"
            exit 1
          }

          $process = Start-Process -FilePath "json-file-test.exe" -Wait -NoNewWindow -PassThru
          Write-Host "JSON file test exit code: $($process.ExitCode)"

          # Show debug output
          $debugFile = "$env:TEMP\json_file_debug.txt"
          if (Test-Path $debugFile) {
            Write-Host "=== DEBUG OUTPUT ==="
            Get-Content $debugFile
            Write-Host "=== END DEBUG ==="
          }

          switch ($process.ExitCode) {
            0 { Write-Host "SUCCESS: nsJSON file loading verified!" }
            2 { Write-Error "FAILED: JSON file not created"; exit 1 }
            3 { Write-Error "FAILED: nsJSON::Get returned wrong value"; exit 1 }
            4 { Write-Error "FAILED: nsJSON::Set /file failed"; exit 1 }
            default { Write-Error "FAILED: Unknown error $($process.ExitCode)"; exit 1 }
          }

      - name: Test FULL auth flow (NScurl POST + nsJSON parse + token extraction)
        shell: pwsh
        env:
          CIDX_SERVER_URL: ${{ secrets.CIDX_TEST_SERVER_URL }}
          CIDX_USERNAME: ${{ secrets.CIDX_TEST_USERNAME }}
          CIDX_PASSWORD: ${{ secrets.CIDX_TEST_PASSWORD }}
        run: |
          Write-Host "Testing FULL authentication flow against real CIDX server..."

          # Check if secrets are configured
          if (-not $env:CIDX_SERVER_URL -or -not $env:CIDX_USERNAME -or -not $env:CIDX_PASSWORD) {
            Write-Host "WARNING: CIDX test secrets not configured. Skipping full auth flow test."
            Write-Host "To enable this test, set these repository secrets:"
            Write-Host "  - CIDX_TEST_SERVER_URL (e.g., https://your-server:8383)"
            Write-Host "  - CIDX_TEST_USERNAME"
            Write-Host "  - CIDX_TEST_PASSWORD"
            exit 0
          }

          Write-Host "Server URL: $env:CIDX_SERVER_URL"
          Write-Host "Username: $env:CIDX_USERNAME"
          Write-Host "Password: [REDACTED]"

          # Create NSIS test script with placeholders (use single-quoted here-string)
          $testScript = @'
          !addplugindir "C:\Program Files (x86)\NSIS\Plugins\x86-unicode"
          ; NScurl.nsh not needed - using direct NScurl::http call
          !include "LogicLib.nsh"
          Unicode true

          Name "Full Auth Flow Test"
          OutFile "full-auth-test.exe"
          InstallDir "$TEMP\authtest"
          SilentInstall silent

          Section
            SetOutPath $INSTDIR

            StrCpy $9 "$TEMP\full_auth_debug.txt"
            StrCpy $1 "$TEMP\auth_response.json"

            FileOpen $8 $9 w
            FileWrite $8 "=== FULL AUTH FLOW TEST ===$\r$\n"
            FileWrite $8 "Server: __SERVER_URL__$\r$\n"
            FileWrite $8 "Username: __USERNAME__$\r$\n"

            ; Step 1: NScurl POST to /auth/login - write directly to file (not MEMORY)
            FileWrite $8 "Step 1: NScurl POST to /auth/login (output to file)...$\r$\n"

            NScurl::http POST "__SERVER_URL__/auth/login" "$1" /HEADER "Content-Type: application/json" /DATA '{"username":"__USERNAME__","password":"__PASSWORD__"}' /INSIST /TIMEOUT 30000 /END
            Pop $0

            FileWrite $8 "NScurl status: [$0]$\r$\n"

            ; Check if request succeeded - "OK" means success for file output
            StrCmp $0 "OK" +3
            FileWrite $8 "FAIL: NScurl returned error: $0$\r$\n"
            Goto fail_nscurl

            ; Verify file was created
            IfFileExists $1 +3
            FileWrite $8 "FAIL: Response file not created$\r$\n"
            Goto fail_nscurl

            FileWrite $8 "Response saved to: $1$\r$\n"

            ; Step 3: Parse with nsJSON
            FileWrite $8 "Step 3: Parsing with nsJSON::Set /file...$\r$\n"
            ClearErrors
            nsJSON::Set /file "$1"
            ${If} ${Errors}
              FileWrite $8 "FAIL: nsJSON::Set /file returned error$\r$\n"
              FileClose $8
              SetErrorLevel 3
              Goto done
            ${EndIf}
            FileWrite $8 "nsJSON::Set /file succeeded$\r$\n"

            ; Step 4: Extract access_token
            FileWrite $8 "Step 4: Extracting access_token...$\r$\n"
            nsJSON::Get "access_token" /END
            Pop $2
            FileWrite $8 "access_token: [$2]$\r$\n"

            ; Validate access_token is not empty
            StrCmp $2 "" fail_token
            StrCmp $2 "null" fail_token

            ; Step 5: Extract refresh_token
            FileWrite $8 "Step 5: Extracting refresh_token...$\r$\n"
            nsJSON::Get "refresh_token" /END
            Pop $3
            FileWrite $8 "refresh_token: [$3]$\r$\n"

            ; Validate refresh_token is not empty
            StrCmp $3 "" fail_token
            StrCmp $3 "null" fail_token

            ; SUCCESS!
            FileWrite $8 "=== SUCCESS: Full auth flow completed! ===$\r$\n"
            FileClose $8
            Delete "$1"
            SetErrorLevel 0
            Goto done

          fail_nscurl:
            FileWrite $8 "FAIL: NScurl request failed$\r$\n"
            FileClose $8
            SetErrorLevel 2
            Goto done

          fail_token:
            FileWrite $8 "FAIL: Token extraction failed (empty or null)$\r$\n"
            FileClose $8
            SetErrorLevel 4

          done:
          SectionEnd
          '@

          # Substitute placeholders with actual values
          $testScript = $testScript -replace '__SERVER_URL__', $env:CIDX_SERVER_URL
          $testScript = $testScript -replace '__USERNAME__', $env:CIDX_USERNAME
          $testScript = $testScript -replace '__PASSWORD__', $env:CIDX_PASSWORD

          $testScript | Out-File -FilePath "full-auth-test.nsi" -Encoding ASCII

          Write-Host "Compiling full auth flow test..."
          $makensis = "C:\Program Files (x86)\NSIS\makensis.exe"
          & $makensis /V2 full-auth-test.nsi

          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to compile full auth flow test"
            exit 1
          }

          Write-Host "Running full auth flow test..."
          $process = Start-Process -FilePath "full-auth-test.exe" -Wait -NoNewWindow -PassThru
          Write-Host "Full auth flow test exit code: $($process.ExitCode)"

          # Show debug output
          $debugFile = "$env:TEMP\full_auth_debug.txt"
          if (Test-Path $debugFile) {
            Write-Host "=== DEBUG OUTPUT ==="
            Get-Content $debugFile
            Write-Host "=== END DEBUG ==="
          }

          switch ($process.ExitCode) {
            0 { Write-Host "SUCCESS: Full authentication flow verified against real CIDX server!" }
            2 { Write-Error "FAILED: NScurl POST request failed"; exit 1 }
            3 { Write-Error "FAILED: nsJSON parsing failed"; exit 1 }
            4 { Write-Error "FAILED: Token extraction failed"; exit 1 }
            default { Write-Error "FAILED: Unknown error $($process.ExitCode)"; exit 1 }
          }

      - name: Test installer binary extraction
        shell: pwsh
        run: |
          Write-Host "Verifying installer binary extraction..."

          $installer = "scripts\installer\mcpb-windows-x64-setup.exe"
          $process = Start-Process -FilePath $installer -ArgumentList "/S", "/SERVER_URL=https://localhost:9999", "/USERNAME=test", "/PASSWORD=test" -Wait -NoNewWindow -PassThru

          if (Test-Path "C:\mcpb\server\mcpb-windows-x64.exe") {
            Write-Host "SUCCESS: Binary extraction verified"
          } else {
            Write-Error "FAILED: Binary not extracted"
            exit 1
          }

      - name: Upload installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: mcpb-windows-installer
          path: scripts/installer/mcpb-windows-x64-setup.exe
          retention-days: 1

  create-release:
    name: Create GitHub Release
    needs: [build-binaries, build-windows-installer]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Get version
        id: get_version
        shell: bash
        run: |
          # Always extract version from source code for consistency
          VERSION=$(python3 -c "import sys; sys.path.insert(0, 'src'); from code_indexer import __version__; print(__version__)")
          echo "Version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Create release notes
        run: |
          cat > release-notes.md <<EOF
          # MCP Bridge v${{ steps.get_version.outputs.version }}

          Cross-platform binaries for the MCP Stdio Bridge.

          ## Installation

          ### Windows (Installer)

          1. Download **mcpb-windows-x64-setup.exe** (recommended for Windows users)
          2. Run the installer and follow the authentication wizard
          3. The installer will automatically:
             - Extract MCPB binary to C:\mcpb\server\
             - Authenticate with CIDX server and configure tokens
             - Integrate with Claude Desktop (if installed)

          ### Manual Installation (All Platforms)

          1. Download the appropriate binary for your platform
          2. Extract the ZIP file
          3. Make the binary executable (Unix/macOS): \`chmod +x mcpb-*\`
          4. Configure \`~/.mcpb/config.json\` with your CIDX server details
          5. Add to Claude Desktop MCP configuration

          ## Platforms

          - **Windows Installer**: mcpb-windows-x64-setup.exe (automated setup with GUI)
          - **macOS (Intel)**: mcpb-darwin-x64.zip
          - **macOS (Apple Silicon)**: mcpb-darwin-arm64.zip
          - **Linux (x86_64)**: mcpb-linux-x64.zip
          - **Windows (Manual)**: mcpb-windows-x64.zip

          ## Configuration

          See README.md for full configuration instructions.
          EOF

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.get_version.outputs.version }}
          name: MCP Bridge v${{ steps.get_version.outputs.version }}
          body_path: release-notes.md
          draft: false
          prerelease: false
          files: |
            artifacts/mcpb-darwin-x64/mcpb-darwin-x64.mcpb
            artifacts/mcpb-darwin-arm64/mcpb-darwin-arm64.mcpb
            artifacts/mcpb-linux-x64/mcpb-linux-x64.mcpb
            artifacts/mcpb-windows-x64/mcpb-windows-x64.mcpb
            artifacts/mcpb-windows-installer/mcpb-windows-x64-setup.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
