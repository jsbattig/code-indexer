"""
Test suite for pwdlib migration from passlib.

This test suite verifies:
1. pwdlib can hash and verify passwords correctly
2. pwdlib is backward compatible with existing bcrypt hashes from passlib
3. PasswordManager API remains unchanged after migration
4. TestDataFactory and TestUser work correctly with pwdlib
"""

from pathlib import Path
import sys

# Add src to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent.parent / "src"))

from code_indexer.server.auth.password_manager import PasswordManager


class TestPwdlibIntegration:
    """Test pwdlib library integration and functionality."""

    def test_pwdlib_can_hash_password(self):
        """Test that pwdlib can successfully hash a password."""
        manager = PasswordManager()
        password = "test_password_123"

        hashed = manager.hash_password(password)

        # Verify hash is a string
        assert isinstance(hashed, str)
        # Verify hash is not empty
        assert len(hashed) > 0
        # Verify hash is not the plain password
        assert hashed != password
        # Verify hash starts with bcrypt identifier
        assert (
            hashed.startswith("$2b$")
            or hashed.startswith("$2a$")
            or hashed.startswith("$2y$")
        )

    def test_pwdlib_can_verify_correct_password(self):
        """Test that pwdlib can verify a correct password."""
        manager = PasswordManager()
        password = "correct_password"

        hashed = manager.hash_password(password)
        result = manager.verify_password(password, hashed)

        assert result is True

    def test_pwdlib_rejects_incorrect_password(self):
        """Test that pwdlib correctly rejects an incorrect password."""
        manager = PasswordManager()
        password = "correct_password"
        wrong_password = "wrong_password"

        hashed = manager.hash_password(password)
        result = manager.verify_password(wrong_password, hashed)

        assert result is False

    def test_pwdlib_rejects_empty_password(self):
        """Test that pwdlib correctly rejects empty password verification."""
        manager = PasswordManager()
        password = "correct_password"

        hashed = manager.hash_password(password)
        result = manager.verify_password("", hashed)

        assert result is False

    def test_different_passwords_produce_different_hashes(self):
        """Test that different passwords produce different hashes."""
        manager = PasswordManager()
        password1 = "password1"
        password2 = "password2"

        hash1 = manager.hash_password(password1)
        hash2 = manager.hash_password(password2)

        assert hash1 != hash2

    def test_same_password_produces_different_hashes_due_to_salt(self):
        """Test that hashing the same password twice produces different hashes due to salt."""
        manager = PasswordManager()
        password = "same_password"

        hash1 = manager.hash_password(password)
        hash2 = manager.hash_password(password)

        # Different hashes due to different salts
        assert hash1 != hash2
        # But both should verify correctly
        assert manager.verify_password(password, hash1)
        assert manager.verify_password(password, hash2)


class TestBackwardCompatibilityWithPasslib:
    """Test backward compatibility with existing passlib bcrypt hashes."""

    def test_pwdlib_can_verify_passlib_bcrypt_hash(self):
        """
        Test that pwdlib can verify passwords hashed with passlib bcrypt.

        This is critical for migration - existing password hashes in the database
        must continue to work with pwdlib.
        """
        manager = PasswordManager()

        # This is a real bcrypt hash generated by passlib for password "test123"
        # Generated with: CryptContext(schemes=["bcrypt"]).hash("test123")
        passlib_hash = "$2b$12$W/FFnoGLoITxIuzfDP0IqueVFT1cEJAEk9C/AE.WruaDSCm/kPUp2"

        # pwdlib should be able to verify this passlib-generated hash
        result = manager.verify_password("test123", passlib_hash)

        assert result is True, "pwdlib should verify passlib-generated bcrypt hashes"

    def test_pwdlib_rejects_wrong_password_for_passlib_hash(self):
        """Test that pwdlib correctly rejects wrong password for passlib hash."""
        manager = PasswordManager()

        # Passlib-generated hash for "test123"
        passlib_hash = "$2b$12$W/FFnoGLoITxIuzfDP0IqueVFT1cEJAEk9C/AE.WruaDSCm/kPUp2"

        # Wrong password should fail
        result = manager.verify_password("wrong_password", passlib_hash)

        assert result is False


class TestPasswordManagerAPICompatibility:
    """Test that PasswordManager API remains unchanged after pwdlib migration."""

    def test_password_manager_has_hash_password_method(self):
        """Test that PasswordManager has hash_password method."""
        manager = PasswordManager()
        assert hasattr(manager, "hash_password")
        assert callable(manager.hash_password)

    def test_password_manager_has_verify_password_method(self):
        """Test that PasswordManager has verify_password method."""
        manager = PasswordManager()
        assert hasattr(manager, "verify_password")
        assert callable(manager.verify_password)

    def test_hash_password_accepts_string_returns_string(self):
        """Test that hash_password accepts string and returns string."""
        manager = PasswordManager()
        password = "test_password"

        hashed = manager.hash_password(password)

        assert isinstance(hashed, str)

    def test_verify_password_accepts_two_strings_returns_bool(self):
        """Test that verify_password accepts two strings and returns bool."""
        manager = PasswordManager()
        password = "test_password"
        hashed = manager.hash_password(password)

        result = manager.verify_password(password, hashed)

        assert isinstance(result, bool)

    def test_verify_password_signature_order_is_plain_then_hashed(self):
        """
        Test that verify_password signature is (plain_password, hashed_password).

        This is critical - the API must remain (plain, hash) even though
        pwdlib internally uses (hash, plain).
        """
        manager = PasswordManager()
        password = "test_password"
        hashed = manager.hash_password(password)

        # Should work with (plain, hash) order
        result = manager.verify_password(password, hashed)
        assert result is True

        # Verify by checking method signature
        import inspect

        sig = inspect.signature(manager.verify_password)
        params = list(sig.parameters.keys())

        # First parameter should be plain password
        assert params[0] == "plain_password" or "plain" in params[0].lower()
        # Second parameter should be hashed password
        assert params[1] == "hashed_password" or "hash" in params[1].lower()


class TestPasswordManagerInitialization:
    """Test PasswordManager initialization works correctly."""

    def test_password_manager_can_be_instantiated(self):
        """Test that PasswordManager can be instantiated without errors."""
        manager = PasswordManager()
        assert manager is not None

    def test_password_manager_is_ready_after_instantiation(self):
        """Test that PasswordManager is ready to use immediately after instantiation."""
        manager = PasswordManager()

        # Should be able to hash immediately
        hashed = manager.hash_password("test")
        assert hashed is not None

        # Should be able to verify immediately
        result = manager.verify_password("test", hashed)
        assert result is True


class TestTestDataFactoryCompatibility:
    """Test that TestDataFactory works correctly with pwdlib."""

    def test_test_data_factory_import_does_not_fail(self):
        """Test that TestDataFactory can be imported without errors."""
        from tests.utils.test_data_factory import TestDataFactory

        assert TestDataFactory is not None

    def test_test_data_factory_can_create_user(self):
        """Test that TestDataFactory can create a user with hashed password."""
        from tests.utils.test_data_factory import TestDataFactory

        factory = TestDataFactory()
        user = factory.create_test_user(
            username="testuser", role="normal_user", password="testpassword"
        )

        assert user is not None
        assert user.username == "testuser"
        assert user.password_hash is not None
        assert len(user.password_hash) > 0
        assert user.password_hash != "testpassword"

    def test_test_user_can_verify_password(self):
        """Test that TestUser can verify passwords correctly."""
        from tests.utils.test_data_factory import TestDataFactory

        factory = TestDataFactory()
        user = factory.create_test_user(
            username="testuser", role="normal_user", password="correct_password"
        )

        # Correct password should verify
        assert user.verify_password("correct_password") is True
        # Wrong password should fail
        assert user.verify_password("wrong_password") is False


class TestNoPasblibImportsRemain:
    """Test that no passlib imports remain in the codebase after migration."""

    def test_password_manager_does_not_import_passlib(self):
        """Test that PasswordManager does not import passlib."""
        import code_indexer.server.auth.password_manager as pm_module

        # Get module source code
        import inspect

        source = inspect.getsource(pm_module)

        # Should not contain passlib imports
        assert (
            "from passlib" not in source
        ), "PasswordManager still imports from passlib"
        assert "import passlib" not in source, "PasswordManager still imports passlib"

    def test_password_manager_imports_pwdlib(self):
        """Test that PasswordManager imports pwdlib."""
        import code_indexer.server.auth.password_manager as pm_module

        import inspect

        source = inspect.getsource(pm_module)

        # Should import pwdlib
        assert (
            "from pwdlib" in source or "import pwdlib" in source
        ), "PasswordManager should import pwdlib"

    def test_test_data_factory_does_not_import_passlib(self):
        """Test that TestDataFactory does not import passlib."""
        import tests.utils.test_data_factory as tdf_module

        import inspect

        source = inspect.getsource(tdf_module)

        # Should not contain passlib imports
        assert (
            "from passlib" not in source
        ), "TestDataFactory still imports from passlib"
        assert "import passlib" not in source, "TestDataFactory still imports passlib"

    def test_test_data_factory_imports_pwdlib(self):
        """Test that TestDataFactory imports pwdlib."""
        import tests.utils.test_data_factory as tdf_module

        import inspect

        source = inspect.getsource(tdf_module)

        # Should import pwdlib
        assert (
            "from pwdlib" in source or "import pwdlib" in source
        ), "TestDataFactory should import pwdlib"
